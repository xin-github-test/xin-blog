<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>xin 的 博客 | xin 的 博客</title><meta name="author" content="xin,1246814044@qq.com"><meta name="copyright" content="xin"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="title: Spring 源码解读date: 2025-11-16 09:55:01tags:  - java  - Spring  - encryptcategory: note  Spring-5.3.8整体框架图网上找的spring框架图：  从图中可以看出，最底层是 Core Container,因此先从这部分开始 1.Spring-Core在Core模块下，一共包含以下子包：asm">
<meta property="og:type" content="article">
<meta property="og:title" content="xin 的 博客">
<meta property="og:url" content="https://blog.wxin.icu/2025/11/16/Spring-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/index.html">
<meta property="og:site_name" content="xin 的 博客">
<meta property="og:description" content="title: Spring 源码解读date: 2025-11-16 09:55:01tags:  - java  - Spring  - encryptcategory: note  Spring-5.3.8整体框架图网上找的spring框架图：  从图中可以看出，最底层是 Core Container,因此先从这部分开始 1.Spring-Core在Core模块下，一共包含以下子包：asm">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.wxin.icu/img/default/2.png">
<meta property="article:published_time" content="2025-11-16T11:31:26.255Z">
<meta property="article:modified_time" content="2025-12-14T12:04:01.135Z">
<meta property="article:author" content="xin">
<meta property="article:tag" content="生活 歌曲 技术">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.wxin.icu/img/default/2.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "",
  "url": "https://blog.wxin.icu/2025/11/16/Spring-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/",
  "image": "https://blog.wxin.icu/img/default/2.png",
  "datePublished": "2025-11-16T11:31:26.255Z",
  "dateModified": "2025-12-14T12:04:01.135Z",
  "author": [
    {
      "@type": "Person",
      "name": "xin",
      "url": "https://blog.wxin.icu"
    }
  ]
}</script><link rel="shortcut icon" href="/img/logo.png"><link rel="canonical" href="https://blog.wxin.icu/2025/11/16/Spring-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":false,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'xin 的 博客',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      if ($loadingBox.classList.contains('loaded')) return
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()

  if (document.readyState === 'complete') {
    preloader.endLoading()
  } else {
    window.addEventListener('load', preloader.endLoading)
    document.addEventListener('DOMContentLoaded', preloader.endLoading)
    // Add timeout protection: force end after 7 seconds
    setTimeout(preloader.endLoading, 7000)
  }

  if (true) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="web_bg" style="background-image: url(/img/background.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/default/2.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/loading.gif" data-lazy-src="/img/logo.png" alt="Logo"><span class="site-name">xin 的 博客</span></a><a class="nav-page-title" href="/"><span class="site-name">xin 的 博客</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">无标题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-11-16T11:31:26.255Z" title="发表于 2025-11-16 19:31:26">2025-11-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-12-14T12:04:01.135Z" title="更新于 2025-12-14 20:04:01">2025-12-14</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">14.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>57分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:365,&quot;messagePrev&quot;:&quot;距离文章发布已经过了&quot;,&quot;messageNext&quot;:&quot;天，部分内容可能已经过时。&quot;,&quot;postUpdate&quot;:&quot;2025-12-14 20:04:01&quot;}" hidden></div><ol>
<li><hr>
<h2 id="title-Spring-源码解读date-2025-11-16-09-55-01tags-java-Spring-encryptcategory-note"><a href="#title-Spring-源码解读date-2025-11-16-09-55-01tags-java-Spring-encryptcategory-note" class="headerlink" title="title: Spring 源码解读date: 2025-11-16 09:55:01tags:  - java  - Spring  - encryptcategory: note"></a>title: Spring 源码解读<br>date: 2025-11-16 09:55:01<br>tags:<br>  - java<br>  - Spring<br>  - encrypt<br>category: note</h2></li>
</ol>
<h1 id="Spring-5-3-8"><a href="#Spring-5-3-8" class="headerlink" title="Spring-5.3.8"></a>Spring-5.3.8</h1><h1 id="整体框架图"><a href="#整体框架图" class="headerlink" title="整体框架图"></a>整体框架图</h1><p>网上找的spring框架图：</p>
<p><img src="/img/loading.gif" data-lazy-src="https://docs.spring.io/spring-framework/docs/4.3.x/spring-framework-reference/html/images/spring-overview.png" alt="spring overview"></p>
<p>从图中可以看出，最底层是 <code>Core Container</code>,因此先从这部分开始</p>
<h1 id="1-Spring-Core"><a href="#1-Spring-Core" class="headerlink" title="1.Spring-Core"></a>1.Spring-Core</h1><p>在<code>Core</code>模块下，一共包含以下子包：<strong>asm</strong>、<strong>cglib</strong>、<strong>core</strong>、<strong>lang</strong>、<strong>objenesis</strong>、<strong>util</strong>； 这些包各自承担着重要的基础支持角色</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">┌─────────┐    ┌─────────┐    ┌─────────┐</span><br><span class="line">│  asm    │◄──►│ cglib   │◄──►│objenesis│</span><br><span class="line">│(字节码) │    │(代理生成)│    │(实例化) │</span><br><span class="line">└─────────┘    └─────────┘    └─────────┘</span><br><span class="line">      │              │              │</span><br><span class="line">      ▼              ▼              ▼</span><br><span class="line">┌─────────────────────────────────────────┐</span><br><span class="line">│                core包                    │  ← 基础框架</span><br><span class="line">│           (核心接口和容器)                │</span><br><span class="line">└─────────────────────────────────────────┘</span><br><span class="line">      │              ▲</span><br><span class="line">      ▼              │</span><br><span class="line">┌─────────┐    ┌─────────┐</span><br><span class="line">│  lang   │    │  util   │</span><br><span class="line">│(语言增强)│    │(工具类) │</span><br><span class="line">└─────────┘    └─────────┘</span><br></pre></td></tr></table></figure>

<h2 id="1-1asm包：字节码操作框架"><a href="#1-1asm包：字节码操作框架" class="headerlink" title="1.1asm包：字节码操作框架"></a>1.1asm包：字节码操作框架</h2><p>基于<strong>ASM</strong>库进行封装，提供对类字节码文件的读取、分析和修改功能，相比反射更高效（直接读取字节码文件），同时能够自定义生成字节码文件</p>
<p>该包中包含各种<strong>Visitor</strong>(访问器)：负责解析和修改字节码的各个部分，<strong>Writer</strong>(写入器)：负责将修改后的字节码重新组装成新的类文件；核心是基于**访问者模式(Visitor Pattern)**工作的</p>
<h3 id="（1）Visitor（访问器）和-Writer（组装器）"><a href="#（1）Visitor（访问器）和-Writer（组装器）" class="headerlink" title="（1）Visitor（访问器）和 Writer（组装器）"></a>（1）Visitor（访问器）和 Writer（组装器）</h3><ul>
<li><p>**<code>ClassVisitor</code>**：访问类的整体结构，是其他Visitor的入口和调度中心</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源码中对该类的描述</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A visitor to visit a Java class. The methods of this class must be called in the following order:</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> visit&#125; [ &#123;<span class="doctag">@code</span> visitSource&#125; ] [ &#123;<span class="doctag">@code</span> visitModule&#125; ][ &#123;<span class="doctag">@code</span> visitNestHost&#125; ][ &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment"> * visitPermittedSubclass&#125; ][ &#123;<span class="doctag">@code</span> visitOuterClass&#125; ] ( &#123;<span class="doctag">@code</span> visitAnnotation&#125; | &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment"> * visitTypeAnnotation&#125; | &#123;<span class="doctag">@code</span> visitAttribute&#125; )* ( &#123;<span class="doctag">@code</span> visitNestMember&#125; | &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment"> * visitInnerClass&#125; | &#123;<span class="doctag">@code</span> visitRecordComponent&#125; | &#123;<span class="doctag">@code</span> visitField&#125; | &#123;<span class="doctag">@code</span> visitMethod&#125; )*</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> visitEnd&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Eric Bruneton</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//翻译</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">用于访问Java类的访问者。该接口的方法必须按以下顺序调用：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#123;<span class="doctag">@code</span> visit&#125; [ &#123;<span class="doctag">@code</span> visitSource&#125; ] [ &#123;<span class="doctag">@code</span> visitModule&#125; ][ &#123;<span class="doctag">@code</span> visitNestHost&#125; ][ &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">visitPermittedSubclass&#125; ][ &#123;<span class="doctag">@code</span> visitOuterClass&#125; ] ( &#123;<span class="doctag">@code</span> visitAnnotation&#125; | &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">visitTypeAnnotation&#125; | &#123;<span class="doctag">@code</span> visitAttribute&#125; )* ( &#123;<span class="doctag">@code</span> visitNestMember&#125; | &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">visitInnerClass&#125; | &#123;<span class="doctag">@code</span> visitRecordComponent&#125; | &#123;<span class="doctag">@code</span> visitField&#125; | &#123;<span class="doctag">@code</span> visitMethod&#125; )*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#123;<span class="doctag">@code</span> visitEnd&#125;。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"><span class="doctag">@author</span> Eric Bruneton</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>ClassWriter</code></strong>:类字节码生成器，动态生成新的Java类字节码<br><strong>ClassVisitor</strong>的子类，用于修改并生成新的字节码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例子1:分析类信息：打印所有方法名</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * (1)测试 ClassVisitor:分析类信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodAnalyzerVisitor</span> <span class="keyword">extends</span> <span class="title class_">ClassVisitor</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String className;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">MethodAnalyzerVisitor</span><span class="params">(<span class="type">int</span> api, ClassVisitor cv, String className)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(api, cv);</span><br><span class="line">            <span class="built_in">this</span>.className = className;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> MethodVisitor <span class="title function_">visitMethod</span><span class="params">(<span class="type">int</span> access, String name, String descriptor, String signature, String[] exceptions)</span> &#123;</span><br><span class="line">            <span class="comment">// 打印每个方法的名称和描述符（参数与返回值类型）</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Method: &quot;</span> + className + <span class="string">&quot; | Descriptor: &quot;</span> + descriptor);</span><br><span class="line">            <span class="comment">// 调用父类方法，确保链条不断（如需生成则必须调用）</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.visitMethod(access, name, descriptor, signature, exceptions);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testClassVisitor1</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        String[] exp = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;test&quot;</span>,<span class="string">&quot;test1&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">//测试访问者链</span></span><br><span class="line">        <span class="type">MethodAnalyzerVisitor</span> <span class="variable">methodAnalyzerVisitorStart</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MethodAnalyzerVisitor</span>(Opcodes.ASM9, <span class="literal">null</span>,<span class="string">&quot;start&quot;</span>);</span><br><span class="line">        <span class="type">MethodAnalyzerVisitor</span> <span class="variable">methodAnalyzerVisitorToA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MethodAnalyzerVisitor</span>(Opcodes.ASM9, methodAnalyzerVisitorStart,<span class="string">&quot;toA&quot;</span>);</span><br><span class="line">        <span class="type">MethodAnalyzerVisitor</span> <span class="variable">methodAnalyzerVisitorToB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MethodAnalyzerVisitor</span>(Opcodes.ASM9, methodAnalyzerVisitorToA,<span class="string">&quot;toB&quot;</span>);</span><br><span class="line">        <span class="type">MethodAnalyzerVisitor</span> <span class="variable">methodAnalyzerVisitorEnd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MethodAnalyzerVisitor</span>(Opcodes.ASM9, methodAnalyzerVisitorToB,<span class="string">&quot;toEnd&quot;</span>);</span><br><span class="line"></span><br><span class="line">        methodAnalyzerVisitorEnd.visitMethod(<span class="number">1</span>, <span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>, exp);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例子2：修改类行为</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggingClassVisitor</span> <span class="keyword">extends</span> <span class="title class_">ClassVisitor</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String className;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LoggingClassVisitor</span><span class="params">(<span class="type">int</span> api, ClassWriter cw)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(api, cw);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(<span class="type">int</span> version, <span class="type">int</span> access, String name, String signature, String superName, String[] interfaces)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.visit(version, access, name, signature, superName, interfaces);</span><br><span class="line">        <span class="built_in">this</span>.className = name; <span class="comment">// 记录当前类名</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> MethodVisitor <span class="title function_">visitMethod</span><span class="params">(<span class="type">int</span> access, String name, String desc, String signature, String[] exceptions)</span> &#123;</span><br><span class="line">        <span class="type">MethodVisitor</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="built_in">super</span>.visitMethod(access, name, desc, signature, exceptions);</span><br><span class="line">        <span class="keyword">if</span> (!name.equals(<span class="string">&quot;&lt;init&gt;&quot;</span>) &amp;&amp; !name.equals(<span class="string">&quot;&lt;clinit&gt;&quot;</span>)) &#123; <span class="comment">// 过滤构造器和静态初始化器</span></span><br><span class="line">            <span class="comment">// 返回一个自定义的 MethodVisitor，用于注入日志字节码</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LoggingMethodVisitor</span>(api, mv, className, name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 自定义 MethodVisitor 用于实际注入指令（注入 System.out.println）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoggingMethodVisitor</span> <span class="keyword">extends</span> <span class="title class_">MethodVisitor</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String className;</span><br><span class="line">    <span class="keyword">private</span> String methodName;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LoggingMethodVisitor</span><span class="params">(<span class="type">int</span> api, MethodVisitor mv, String className, String methodName)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(api, mv);</span><br><span class="line">        <span class="built_in">this</span>.className = className;</span><br><span class="line">        <span class="built_in">this</span>.methodName = methodName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.visitCode();</span><br><span class="line">        <span class="comment">// 在方法开始处插入：System.out.println(&quot;Entering: className.methodName&quot;);</span></span><br><span class="line">        <span class="built_in">super</span>.visitFieldInsn(GETSTATIC, <span class="string">&quot;java/lang/System&quot;</span>, <span class="string">&quot;out&quot;</span>, <span class="string">&quot;Ljava/io/PrintStream;&quot;</span>);</span><br><span class="line">        <span class="built_in">super</span>.visitLdcInsn(<span class="string">&quot;Entering: &quot;</span> + className + <span class="string">&quot;.&quot;</span> + methodName);</span><br><span class="line">        <span class="built_in">super</span>.visitMethodInsn(INVOKEVIRTUAL, <span class="string">&quot;java/io/PrintStream&quot;</span>, <span class="string">&quot;println&quot;</span>, <span class="string">&quot;(Ljava/lang/String;)V&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitInsn</span><span class="params">(<span class="type">int</span> opcode)</span> &#123;</span><br><span class="line">        <span class="comment">// 在返回指令前插入退出日志（处理 RETURN, IRETURN, ARETURN 等）</span></span><br><span class="line">        <span class="keyword">if</span> ((opcode &gt;= IRETURN &amp;&amp; opcode &lt;= RETURN) || opcode == ATHROW) &#123;</span><br><span class="line">            <span class="built_in">super</span>.visitFieldInsn(GETSTATIC, <span class="string">&quot;java/lang/System&quot;</span>, <span class="string">&quot;out&quot;</span>, <span class="string">&quot;Ljava/io/PrintStream;&quot;</span>);</span><br><span class="line">            <span class="built_in">super</span>.visitLdcInsn(<span class="string">&quot;Exiting: &quot;</span> + className + <span class="string">&quot;.&quot;</span> + methodName);</span><br><span class="line">            <span class="built_in">super</span>.visitMethodInsn(INVOKEVIRTUAL, <span class="string">&quot;java/io/PrintStream&quot;</span>, <span class="string">&quot;println&quot;</span>, <span class="string">&quot;(Ljava/lang/String;)V&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">super</span>.visitInsn(opcode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggingTest</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 定义一个简单的测试类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;计算中...&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> a + b;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subtract</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> a - b;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printHello</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 测试方法</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testLoggingClassVisitor</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 读取Calculator类的字节码</span></span><br><span class="line">        <span class="type">ClassReader</span> <span class="variable">cr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassReader</span>(Calculator.class.getName());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建ClassWriter</span></span><br><span class="line">        <span class="type">ClassWriter</span> <span class="variable">cw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassWriter</span>(cr, ClassWriter.COMPUTE_MAXS | ClassWriter.COMPUTE_FRAMES);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建LoggingClassVisitor（我们之前定义的）</span></span><br><span class="line">        <span class="type">LoggingClassVisitor</span> <span class="variable">loggingVisitor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoggingClassVisitor</span>(Opcodes.ASM9, cw);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 应用修改</span></span><br><span class="line">        cr.accept(loggingVisitor, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取修改后的字节码</span></span><br><span class="line">        <span class="type">byte</span>[] modifiedBytes = cw.toByteArray();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 加载修改后的类</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassLoader</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">                <span class="keyword">if</span> (name.equals(Calculator.class.getName())) &#123;</span><br><span class="line">                    <span class="keyword">return</span> defineClass(name, modifiedBytes, <span class="number">0</span>, modifiedBytes.length);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">super</span>.findClass(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. 创建实例并调用方法</span></span><br><span class="line">        Class&lt;?&gt; modifiedCalculatorClass = classLoader.loadClass(Calculator.class.getName());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> modifiedCalculatorClass.getDeclaredConstructor().newInstance();</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;=== 测试 add 方法 ===&quot;</span>);</span><br><span class="line">        <span class="type">Method</span> <span class="variable">addMethod</span> <span class="operator">=</span> modifiedCalculatorClass.getMethod(<span class="string">&quot;add&quot;</span>, <span class="type">int</span>.class, <span class="type">int</span>.class);</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> (<span class="type">int</span>) addMethod.invoke(instance, <span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;结果: &quot;</span> + result);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;\n=== 测试 subtract 方法 ===&quot;</span>);</span><br><span class="line">        <span class="type">Method</span> <span class="variable">subtractMethod</span> <span class="operator">=</span> modifiedCalculatorClass.getMethod(<span class="string">&quot;subtract&quot;</span>, <span class="type">int</span>.class, <span class="type">int</span>.class);</span><br><span class="line">        result = (<span class="type">int</span>) subtractMethod.invoke(instance, <span class="number">10</span>, <span class="number">4</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;结果: &quot;</span> + result);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;\n=== 测试 printHello 方法 ===&quot;</span>);</span><br><span class="line">        <span class="type">Method</span> <span class="variable">printHelloMethod</span> <span class="operator">=</span> modifiedCalculatorClass.getMethod(<span class="string">&quot;printHello&quot;</span>);</span><br><span class="line">        printHelloMethod.invoke(instance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>其他<strong>Visitor</strong>和<strong>Writer</strong></p>
<table>
<thead>
<tr>
<th align="center">Visitor</th>
<th align="center">作用</th>
<th align="center">Writer</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">AnnotationVisitor</td>
<td align="center">访问类中的注解信息</td>
<td align="center">AnnotationWriter</td>
<td align="center">AnnotationVisitor的子类，通过字节码修改类的注解</td>
</tr>
<tr>
<td align="center">FieldVisitor</td>
<td align="center">访问类中的属性信息</td>
<td align="center">FieldWriter</td>
<td align="center">FieldVisitor的子类，通过字节码修改类的属性</td>
</tr>
<tr>
<td align="center">MethodVisitor</td>
<td align="center">访问类中的方法信息</td>
<td align="center">MethodWriter</td>
<td align="center">MethodVisitor的子类，通过字节码修改类的方法（Cglib动态代理）</td>
</tr>
<tr>
<td align="center">ModuleVisitor</td>
<td align="center">用于访问 <strong>Java 模块描述信息</strong></td>
<td align="center">ModuleWriter</td>
<td align="center">ModuleVisitor的子类，通过字节码修改 <strong>Java 模块描述信息</strong></td>
</tr>
<tr>
<td align="center">RecordComponentVisitor</td>
<td align="center"><strong>专门用于访问 Java Record 类组件（Component）的访问者</strong>。它是 Java 14 引入 <code>Record</code> 语言特性在字节码层面的直接对应物</td>
<td align="center">RecordComponentWriter</td>
<td align="center">RecordComponentVisitor的子类，通过字节码修改 <strong>Java Record 类组件</strong></td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<h3 id="（2）Attribute类"><a href="#（2）Attribute类" class="headerlink" title="（2）Attribute类"></a>（2）Attribute类</h3><p>可以通过继承该类，实现在类字节码中添加自定义属性，也可以用于存储标准字节码结构无法承载的额外信息</p>
<p>jvm常见的内置属性：</p>
<ul>
<li>**<code>Code</code>**：方法的字节码和异常表，这是最重要的属性。</li>
<li>**<code>LineNumberTable</code>**：源代码行号与字节码的映射，用于调试。</li>
<li>**<code>LocalVariableTable</code>**：局部变量信息。</li>
<li>**<code>SourceFile</code>**：源文件名称。</li>
<li>**<code>ConstantValue</code>**：用于 <code>final</code> 静态基本类型字段的常量值。</li>
<li>**<code>Exceptions</code>**：方法声明的受检异常。</li>
<li>**<code>Signature</code>**：泛型签名信息（Java 5+）。</li>
<li>**<code>RuntimeVisibleAnnotations</code> &#x2F; <code>RuntimeInvisibleAnnotations</code>**：运行时可见&#x2F;不可见的注解（Java 5+）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.asm.attribute;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.objectweb.asm.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义属性：存储类的版本信息</span></span><br><span class="line"><span class="comment"> * 属性格式：</span></span><br><span class="line"><span class="comment"> *   - 2字节：主版本号 (major version)</span></span><br><span class="line"><span class="comment"> *   - 2字节：次版本号 (minor version)  </span></span><br><span class="line"><span class="comment"> *   - 8字节：构建时间戳 (long)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VersionInfoAttribute</span> <span class="keyword">extends</span> <span class="title class_">Attribute</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> majorVersion;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> minorVersion;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> buildTimestamp;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">VersionInfoAttribute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&quot;VersionInfo&quot;</span>); <span class="comment">// 属性类型标识符</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">VersionInfoAttribute</span><span class="params">(<span class="type">int</span> major, <span class="type">int</span> minor, <span class="type">long</span> timestamp)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>();</span><br><span class="line">        <span class="built_in">this</span>.majorVersion = major;</span><br><span class="line">        <span class="built_in">this</span>.minorVersion = minor;</span><br><span class="line">        <span class="built_in">this</span>.buildTimestamp = timestamp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Getters and Setters</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMajorVersion</span><span class="params">()</span> &#123; <span class="keyword">return</span> majorVersion; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMajorVersion</span><span class="params">(<span class="type">int</span> majorVersion)</span> &#123; <span class="built_in">this</span>.majorVersion = majorVersion; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMinorVersion</span><span class="params">()</span> &#123; <span class="keyword">return</span> minorVersion; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMinorVersion</span><span class="params">(<span class="type">int</span> minorVersion)</span> &#123; <span class="built_in">this</span>.minorVersion = minorVersion; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getBuildTimestamp</span><span class="params">()</span> &#123; <span class="keyword">return</span> buildTimestamp; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBuildTimestamp</span><span class="params">(<span class="type">long</span> buildTimestamp)</span> &#123; <span class="built_in">this</span>.buildTimestamp = buildTimestamp; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">&quot;VersionInfoAttribute[v%d.%d, built at %tc]&quot;</span>, </span><br><span class="line">            majorVersion, minorVersion, buildTimestamp);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// --- ASM 核心方法实现 ---</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从类文件读取属性数据（反序列化）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cr 类读取器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> offset 属性数据在字节数组中的起始位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length 属性数据长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> buf 字符缓冲区（用于读取字符串）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> codeOff 代码偏移量（对于Code属性）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> labels 标签数组（对于Code属性）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Attribute <span class="title function_">read</span><span class="params">(ClassReader cr, <span class="type">int</span> offset, <span class="type">int</span> length, </span></span><br><span class="line"><span class="params">                           <span class="type">char</span>[] buf, <span class="type">int</span> codeOff, Label[] labels)</span> &#123;</span><br><span class="line">        <span class="comment">// 按照写入顺序读取二进制数据</span></span><br><span class="line">        <span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[length];</span><br><span class="line">        System.arraycopy(cr.b, offset, data, <span class="number">0</span>, length);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 读取2字节主版本号</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">major</span> <span class="operator">=</span> ((data[pos++] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">8</span>) | (data[pos++] &amp; <span class="number">0xFF</span>);</span><br><span class="line">        <span class="comment">// 读取2字节次版本号</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">minor</span> <span class="operator">=</span> ((data[pos++] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">8</span>) | (data[pos++] &amp; <span class="number">0xFF</span>);</span><br><span class="line">        <span class="comment">// 读取8字节时间戳</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            timestamp = (timestamp &lt;&lt; <span class="number">8</span>) | (data[pos++] &amp; <span class="number">0xFF</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">VersionInfoAttribute</span>(major, minor, timestamp);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将属性数据写入类文件（序列化）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> ByteVector <span class="title function_">write</span><span class="params">(ClassWriter cw, <span class="type">byte</span>[] code, </span></span><br><span class="line"><span class="params">                              <span class="type">int</span> len, <span class="type">int</span> maxStack, <span class="type">int</span> maxLocals)</span> &#123;</span><br><span class="line">        <span class="type">ByteVector</span> <span class="variable">bv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteVector</span>();</span><br><span class="line">        <span class="comment">// 写入2字节主版本号</span></span><br><span class="line">        bv.putShort(majorVersion);</span><br><span class="line">        <span class="comment">// 写入2字节次版本号</span></span><br><span class="line">        bv.putShort(minorVersion);</span><br><span class="line">        <span class="comment">// 写入8字节时间戳</span></span><br><span class="line">        bv.putLong(buildTimestamp);</span><br><span class="line">        <span class="keyword">return</span> bv;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回属性内容长度（字节数）</span></span><br><span class="line"><span class="comment">     * 2 + 2 + 8 = 12 字节</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">getLength</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">12</span>; <span class="comment">// short(2) + short(2) + long(8)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>属性写入：和<strong>ClassWriter</strong>和<strong>ClassReader</strong>一样，通过对应的<strong>visitor</strong>访问到对应的属性，然后调用<strong>AttributeWriter</strong>，将新属性写入到字节码中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.asm.attribute;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.objectweb.asm.*;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将 VersionInfoAttribute 写入一个现有类文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AttributeWriter</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为类文件添加版本属性</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inputClass 输入类文件路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> outputClass 输出类文件路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addVersionAttribute</span><span class="params">(String inputClass, String outputClass,</span></span><br><span class="line"><span class="params">                                          <span class="type">int</span> major, <span class="type">int</span> minor)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1. 读取原始类文件</span></span><br><span class="line">        <span class="type">ClassReader</span> <span class="variable">cr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassReader</span>(inputClass);</span><br><span class="line">        <span class="type">ClassWriter</span> <span class="variable">cw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassWriter</span>(cr, ClassWriter.COMPUTE_MAXS);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 创建自定义ClassVisitor来注入属性</span></span><br><span class="line">        <span class="type">ClassVisitor</span> <span class="variable">cv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassVisitor</span>(Opcodes.ASM9, cw) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(<span class="type">int</span> version, <span class="type">int</span> access, String name, </span></span><br><span class="line"><span class="params">                             String signature, String superName, String[] interfaces)</span> &#123;</span><br><span class="line">                <span class="built_in">super</span>.visit(version, access, name, signature, superName, interfaces);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 3. 创建并添加自定义属性</span></span><br><span class="line">                <span class="type">VersionInfoAttribute</span> <span class="variable">attr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VersionInfoAttribute</span>(</span><br><span class="line">                    major, minor, <span class="keyword">new</span> <span class="title class_">Date</span>().getTime());</span><br><span class="line">                <span class="built_in">super</span>.visitAttribute(attr);</span><br><span class="line">                </span><br><span class="line">                System.out.println(<span class="string">&quot;已添加属性: &quot;</span> + attr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. 处理类并生成新字节码</span></span><br><span class="line">        cr.accept(cv, <span class="number">0</span>);</span><br><span class="line">        <span class="type">byte</span>[] modifiedClass = cw.toByteArray();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 5. 写入新文件</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(outputClass)) &#123;</span><br><span class="line">            fos.write(modifiedClass);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;已生成带版本属性的类文件: &quot;</span> + outputClass);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 示例：为当前类本身添加属性</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> <span class="string">&quot;com/example/asm/attribute/SimpleClass.class&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">output</span> <span class="operator">=</span> <span class="string">&quot;SimpleClassWithVersion.class&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        addVersionAttribute(input, output, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读取新加的属性：通过对应的<strong>visitor</strong>访问到对应的属性，然后调用<strong>AttributeReader</strong>，读取新加的属性，然后自定义处理逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.asm.attribute;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.objectweb.asm.*;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从类文件中读取 VersionInfoAttribute</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AttributeReader</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取类文件中的所有 VersionInfoAttribute</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;VersionInfoAttribute&gt; <span class="title function_">readVersionAttributes</span><span class="params">(String className)</span> </span><br><span class="line">            <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        List&lt;VersionInfoAttribute&gt; attributes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="type">ClassReader</span> <span class="variable">cr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassReader</span>(className);</span><br><span class="line">        </span><br><span class="line">        <span class="type">ClassVisitor</span> <span class="variable">cv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassVisitor</span>(Opcodes.ASM9) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitAttribute</span><span class="params">(Attribute attr)</span> &#123;</span><br><span class="line">                <span class="comment">// 识别并处理我们的自定义属性</span></span><br><span class="line">                <span class="keyword">if</span> (attr <span class="keyword">instanceof</span> VersionInfoAttribute) &#123;</span><br><span class="line">                    attributes.add((VersionInfoAttribute) attr);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;VersionInfo&quot;</span>.equals(attr.type)) &#123;</span><br><span class="line">                    <span class="comment">// 也可以动态识别未注册的属性类型</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;发现未知格式的 VersionInfo 属性&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 必须调用super以保持访问链</span></span><br><span class="line">                <span class="built_in">super</span>.visitAttribute(attr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        cr.accept(cv, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> attributes;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取并打印属性信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printClassVersionInfo</span><span class="params">(String className)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;读取类文件: &quot;</span> + className);</span><br><span class="line">        List&lt;VersionInfoAttribute&gt; attrs = readVersionAttributes(className);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (attrs.isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;  未找到 VersionInfo 属性&quot;</span>);</span><br><span class="line">            <span class="comment">// 打印所有属性类型（用于调试）</span></span><br><span class="line">            <span class="type">ClassReader</span> <span class="variable">cr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassReader</span>(className);</span><br><span class="line">            cr.accept(<span class="keyword">new</span> <span class="title class_">ClassVisitor</span>(Opcodes.ASM9) &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitAttribute</span><span class="params">(Attribute attr)</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;  发现属性: &quot;</span> + attr.type);</span><br><span class="line">                    <span class="built_in">super</span>.visitAttribute(attr);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (VersionInfoAttribute attr : attrs) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;  版本: v&quot;</span> + attr.getMajorVersion() + </span><br><span class="line">                                 <span class="string">&quot;.&quot;</span> + attr.getMinorVersion());</span><br><span class="line">                System.out.println(<span class="string">&quot;  构建时间: &quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>(attr.getBuildTimestamp()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 测试读取</span></span><br><span class="line">        printClassVersionInfo(<span class="string">&quot;SimpleClassWithVersion.class&quot;</span>);</span><br><span class="line">        printClassVersionInfo(<span class="string">&quot;java/lang/String.class&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（3）其他类（辅组类）"><a href="#（3）其他类（辅组类）" class="headerlink" title="（3）其他类（辅组类）"></a>（3）其他类（辅组类）</h3><ol>
<li><p><strong>ByteVector</strong><br>ASM 内部的一个<strong>字节数组缓冲区工具类</strong>，专门用于高效构建 <code>.class</code> 文件的二进制内容。你可以把它理解为一个为写入字节码而定制的、功能更强的 <code>ByteArrayOutputStream</code><br>spring中主要用于构建常量池、生成方法字节码、写入属性数据等</p>
<table>
<thead>
<tr>
<th align="left">特点</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>自动扩容</strong></td>
<td align="left">内部数组空间不足时自动扩展（类似 <code>ArrayList</code>）</td>
</tr>
<tr>
<td align="left"><strong>专为字节码设计</strong></td>
<td align="left">提供 <code>putShort</code>, <code>putInt</code> 等方法，直接写入 Java 类文件要求的 <strong>big-endian</strong>（大端序）格式</td>
</tr>
<tr>
<td align="left"><strong>高性能</strong></td>
<td align="left">方法内部不做边界检查（调用者需确保容量）以提升性能</td>
</tr>
<tr>
<td align="left"><strong>链式调用</strong></td>
<td align="left">多数方法返回 <code>this</code>，支持链式调用</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">对比项</th>
<th align="left"><strong>ByteVector</strong></th>
<th align="left"><strong>ByteArrayOutputStream</strong> &#x2F; <strong>byte[]</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>字节序处理</strong></td>
<td align="left"><strong>自动处理大端序</strong>（<code>.class</code>文件要求）</td>
<td align="left">需手动转换（<code>&gt;&gt;</code>移位操作）</td>
</tr>
<tr>
<td align="left"><strong>便捷性</strong></td>
<td align="left">专为类文件设计，方法命名直观（<code>putShort</code>, <code>putInt</code>）</td>
<td align="left">需自行处理基本类型转换</td>
</tr>
<tr>
<td align="left"><strong>性能</strong></td>
<td align="left">为字节码生成优化，减少边界检查</td>
<td align="left">通用型，可能有额外开销</td>
</tr>
<tr>
<td align="left"><strong>ASM集成</strong></td>
<td align="left">与ASM其他组件无缝协作</td>
<td align="left">需要适配</td>
</tr>
</tbody></table>
</li>
<li><p><strong>Opcodes</strong><br><strong>为字节码操作提供统一的、人类可读的常量标识符</strong>，避免直接使用魔数（Magic Numbers）<br>其中主要包括：字节码指令、<strong>类&#x2F;成员访问标志</strong>、<strong>ASM API 版本</strong>、<strong>栈映射帧类型</strong></p>
</li>
<li><p><strong>ConstantDynamic</strong><br>是一种<strong>延迟计算、动态解析的“常量”</strong>：它允许将常量的实际值计算推迟到<strong>首次访问时</strong>，由引导方法（Bootstrap Method）动态决定。这是对传统常量池条目的重大扩展<br>用于字节码指令执行时，动态计算值</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>传统常量（如 <code>CONSTANT_String</code>）</th>
<th><code>ConstantDynamic</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>解析时机</strong></td>
<td>类加载时（链接阶段）解析</td>
<td><strong>首次访问时</strong>动态解析</td>
</tr>
<tr>
<td><strong>值确定性</strong></td>
<td>固定不变</td>
<td>可动态计算（每次程序运行可能不同）</td>
</tr>
<tr>
<td><strong>存储内容</strong></td>
<td>直接值或简单引用</td>
<td><strong>引导方法句柄 + 参数</strong></td>
</tr>
</tbody></table>
</li>
<li><p><strong>Constants</strong><br>Opcodes的具体实现</p>
<table>
<thead>
<tr>
<th align="left">特性维度</th>
<th align="left"><strong><code>Opcodes</code> 接口</strong></th>
<th align="left"><strong><code>Constants</code> 类&#x2F;接口 (内部)</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>主要定位</strong></td>
<td align="left"><strong>面向开发者的API</strong>，是字节码操作的“常量字典”</td>
<td align="left"><strong>面向ASM自身的内部实现</strong>，是原始常量的“仓库”</td>
</tr>
<tr>
<td align="left"><strong>设计目的</strong></td>
<td align="left">提供稳定、清晰、人类可读的符号化常量</td>
<td align="left">集中管理所有原始常量值，便于内部引用和优化</td>
</tr>
<tr>
<td align="left"><strong>可见性</strong></td>
<td align="left"><code>public</code>，对所有使用者开放</td>
<td align="left">通常是<strong>包私有</strong> (<code>package-private</code>) 或 <code>final</code> 类</td>
</tr>
<tr>
<td align="left"><strong>内容</strong></td>
<td align="left">仅包含开发者需要引用的核心常量</td>
<td align="left">可能包含<strong>全部</strong>原始常量，甚至一些内部状态值</td>
</tr>
<tr>
<td align="left"><strong>稳定性</strong></td>
<td align="left"><strong>跨版本稳定</strong>，ASM保证其兼容性</td>
<td align="left"><strong>随时可能变化</strong>，不对外部承诺任何兼容性</td>
</tr>
<tr>
<td align="left"><strong>你应该</strong></td>
<td align="left"><strong>导入并使用它</strong> (<code>import org.objectweb.asm.Opcodes;</code>)</td>
<td align="left"><strong>完全忽略它</strong>，视其为ASM私有实现的一部分</td>
</tr>
</tbody></table>
</li>
<li><p><strong>Context</strong><br><strong>在访问者模式的层层嵌套调用中，保存和传递一些需要跨层级共享的信息</strong>。它本身并不对外（仅在asm包中可见）提供功能，而是辅助ASM内部的其他组件（如 <code>ClassReader</code>）进行工作</p>
</li>
<li><p><strong>CurrentFrame</strong><br>ASM 内部一个非常核心但对外<strong>完全透明</strong>的类。它位于 <code>org.objectweb.asm</code> 包中，是 ASM 实现 <strong>“栈映射帧”（Stack Map Frame）自动计算</strong>这一复杂功能的核心引擎；简单来说，<code>CurrentFrame</code> 是 ASM 在生成或转换方法字节码时，用来<strong>实时追踪、模拟和计算JVM操作数栈与局部变量表类型状态</strong>的“<strong>工作内存</strong>”<br>其核心职责为：<strong>模拟执行指令、记录当前模拟出的状态、处理控制流合并</strong>，通常和 <strong>Frame</strong> 协作，是<strong>ClassWriter</strong>中内部逻辑的底层实现</p>
</li>
<li><p><strong>Frame</strong><br><strong><code>Frame</code> 是 JVM 方法执行过程中，在特定程序点（Program Point）上，操作数栈（Operand Stack）和局部变量表（Local Variable Table）的类型状态的一张“静态照片”</strong><br>是 ASM 中用于表示 <strong>“栈映射帧”（Stack Map Frame）的静态快照</strong>的基础数据结构类。如果说 <code>CurrentFrame</code> 是负责动态计算的“工程师”，那么 <code>Frame</code> 就是工程师使用的 <strong>“标准化数据表格”</strong> 或 <strong>“状态记录单”</strong><br><strong>CurrentFrame</strong>和<strong>Frame</strong>共同协作完成栈映射帧的计算</p>
</li>
<li><p><strong>Edge</strong><br>构建控制流图：和 <code>Frame</code>、<code>BasicBlock</code> 等内部类协同工作，帮助 ASM 在分析一个方法时，理解和模拟其<strong>执行路径</strong><br>（1）**<code>Frame</code> 是“状态快照”<strong>：记录程序执行到某一点时，局部变量表和操作数栈的类型状态<br>（2）</strong><code>BasicBlock</code> 是“基本单元”<strong>：代表一段顺序执行、没有分支跳入或跳出的线性代码块<br>（3）</strong><code>Edge</code> 是“连接线”<strong>：表示从一个 <code>BasicBlock</code> 到另一个 <code>BasicBlock</code> 的</strong>可能跳转路径**。例如，一个 <code>IFNE</code>（如果不等于则跳转）指令会创建两条 <code>Edge</code>：一条指向条件为真时跳转的目标块，另一条指向条件为假时顺序执行的下一个块;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">    subgraph A[输入与初始化]</span><br><span class="line">        A1[ASM读取方法字节码] --&gt; A2[初始化首个Frame&lt;br&gt;设置方法参数类型]</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    subgraph B[构建控制流图]</span><br><span class="line">        direction TB</span><br><span class="line">        B1[创建BasicBlock&lt;br&gt;（线性指令序列）] --&gt; B2[分析跳转指令&lt;br&gt;（IFNE, GOTO等）]</span><br><span class="line">        B2 --&gt; B3[创建Edge&lt;br&gt;（连接BasicBlock）]</span><br><span class="line">        B3 --&gt; B4[形成完整的控制流图]</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    subgraph C[模拟执行与状态传播]</span><br><span class="line">        C1[从入口Frame开始] --&gt; C2[沿着Edge遍历所有路径]</span><br><span class="line">        C2 --&gt; C3[在每个BasicBlock出口&lt;br&gt;合并/计算新的Frame状态]</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    subgraph D[输出]</span><br><span class="line">        D1[在所有必要位置&lt;br&gt;生成最终的StackMapTable属性]</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    A --&gt; B</span><br><span class="line">    B --&gt; C</span><br><span class="line">    C --&gt; D</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Handle</strong><br>是 <strong>Java 方法句柄（<code>java.lang.invoke.MethodHandle</code>）在字节码层面的直接表示</strong>。它是在 <code>.class</code> 文件中存储对方法、构造函数或字段的“可执行引用”的标准方式<br>简单来说，<code>Handle</code> 是 <strong><code>invokedynamic</code> 指令和动态常量的“燃料”</strong>，是实现动态语言特性和现代 Java 特性的核心载体<br>一个 <code>Handle</code> 对象精确描述了一个可以调用的目标，它包含了在运行时定位并调用该方法（或访问字段）所需的全部信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tag       调用类型（见下方表格）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> owner     方法所属的类（内部名，如 &quot;java/lang/String&quot;）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name      方法名或字段名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> descriptor 方法描述符或字段描述符</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> isInterface 如果owner是接口，则为true</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Handle(<span class="type">int</span> tag, String owner, String name, String descriptor, <span class="type">boolean</span> isInterface)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">概念</th>
<th align="left">关系</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><code>java.lang.invoke.MethodHandle</code></strong></td>
<td align="left"><strong>运行时对应物</strong>。<code>Handle</code> 是编译时&#x2F;字节码层面的描述；当类被加载、<code>invokedynamic</code> 指令首次执行时，JVM 会利用 <code>Handle</code> 的信息在上下文中查找并创建一个真正的 <code>MethodHandle</code> 对象。</td>
</tr>
<tr>
<td align="left"><strong><code>MethodVisitor.visitMethodInsn()</code></strong></td>
<td align="left"><strong>传统调用 vs 动态调用</strong>。<code>visitMethodInsn</code> 用于生成固定的 <code>invokevirtual</code> 等指令，调用目标在编译时确定。而 <code>Handle</code> 作为 <code>invokedynamic</code> 的参数，<strong>调用目标可以在运行时由引导方法决定和链接</strong>，灵活得多。</td>
</tr>
<tr>
<td align="left"><strong><code>ConstantDynamic</code></strong></td>
<td align="left"><strong>动态常量的“发动机”</strong>。<code>ConstantDynamic</code> 必须包含一个引导方法 <code>Handle</code>，该 <code>Handle</code> 决定了常量值如何生成。</td>
</tr>
</tbody></table>
<p>通俗解释：</p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">核心思想</th>
<th align="left">类比</th>
<th align="left">关键优势</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><code>invokedynamic</code></strong></td>
<td align="left"><strong>延迟链接</strong>。将“调用哪个具体方法”的决定，从编译器搬家到第一次运行的瞬间。由“引导方法”在运行时现场组装或查找目标。</td>
<td align="left"><strong>智能调度中心</strong>（动态派单）</td>
<td align="left"><strong>灵活性</strong>：支持Lambda、字符串连接等需要运行时生成代码或适配类型的场景。为JVM上的动态语言（如JRuby）提供了原生级支持。</td>
</tr>
<tr>
<td align="left"><strong><code>ConstantDynamic</code></strong></td>
<td align="left"><strong>延迟计算&#x2F;解析</strong>。将“常量的值是什么”的计算，从类加载时推迟到第一次访问时。由“引导方法”在运行时现场计算。</td>
<td align="left"><strong>特调饮料订单</strong>（现点现做）</td>
<td align="left"><strong>灵活性 &amp; 性能</strong>：可以创建依赖于运行时环境（配置、Locale）的“常量”。避免在类加载时就初始化昂贵但可能永不使用的资源。</td>
</tr>
</tbody></table>
</li>
<li><p><strong>Handler</strong><br>专门用来<strong>封装和管理异常处理器（try-catch块）信息</strong>的数据结构<br>是ASM在实现 <code>MethodVisitor</code> 和生成 <code>Code</code> 属性时，用于<strong>精确对应并构建《Java虚拟机规范》中 <code>exception_table</code>（异常处理表）的“构建块”</strong><br>它的一个实例直接对应JVM规范中 <code>Code</code> 属性的 <code>exception_table</code> 数组的一个条目<br>通过 <code>nextHandler</code> 字段，多个 <code>Handler</code> 实例可以链接起来，从而完整描述一个方法中所有的 <code>try-catch</code>、<code>try-catch-catch</code> 以及 <code>finally</code>（通过特殊的异常类型）块。这种链表设计非常高效，便于在遍历字节码时动态构建和最终线性化写入</p>
</li>
<li><p><strong>Label</strong><br>是<strong>控制流（跳转、循环、异常处理）的“锚点”或“路标”</strong><br>核心价值在于，它让编写包含跳转和复杂控制流的字节码变得<strong>像写高级语言一样直观</strong>，而无需手动计算繁琐的字节码偏移量<br>如果没有 <code>Label</code>，你就需要像早期汇编程序员一样，<strong>手动计算每条指令的字节数，然后算出跳转目标的绝对偏移量</strong>。这极其繁琐且极易出错，任何中间指令的增减都会导致后续所有偏移量失效</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Label</span> <span class="variable">elseLabel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>(); <span class="comment">// 创建“else块开始”的标签</span></span><br><span class="line"><span class="type">Label</span> <span class="variable">endLabel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>();  <span class="comment">// 创建“if语句结束”的标签</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 条件判断：如果条件不成立（IFEQ），则跳转到 elseLabel</span></span><br><span class="line">mv.visitJumpInsn(Opcodes.IFEQ, elseLabel);</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- then 块的字节码 ---</span></span><br><span class="line">mv.visitLdcInsn(<span class="string">&quot;Then Block&quot;</span>);</span><br><span class="line">mv.visitInsn(Opcodes.RETURN);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标记 else 块开始的位置</span></span><br><span class="line">mv.visitLabel(elseLabel);</span><br><span class="line"><span class="comment">// --- else 块的字节码 ---</span></span><br><span class="line">mv.visitLdcInsn(<span class="string">&quot;Else Block&quot;</span>);</span><br><span class="line">mv.visitInsn(Opcodes.RETURN);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标记整个if语句结束的位置（此例中，then块已有RETURN，这里仅为演示）</span></span><br><span class="line">mv.visitLabel(endLabel);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>SpringAsmInfo</strong><br>是 Spring 框架内部定义的一个<strong>标记性类</strong>，它的核心作用是 <strong>“ASM字节码操作的版本和来源标识”</strong><br>主要作用有两个：<strong>标记来源</strong>、<strong>版本追踪</strong></p>
</li>
<li><p><strong>Symbol</strong> 和 <strong>SymbolTable</strong><br><code>Symbol</code> 和 <code>SymbolTable</code> 是两个<strong>协同工作的核心内部类</strong>，它们共同构成了ASM高效管理 <strong><code>.class</code> 文件常量池（Constant Pool）</strong> 的“<strong>大脑和记忆中枢</strong>”<br>简单来说，它们负责将你代码中的各种符号引用（如类名、方法名、字符串字面量）转换成JVM所需的、紧凑的常量池索引，并确保其唯一性，是ASM高效生成正确字节码的基石<br><code>SymbolTable</code> 通常作为 <code>ClassWriter</code> 的一个核心字段存在。它与 <code>Label</code>、<code>Frame</code> 等组件紧密协作<br>若是没有<code>SymbolTable</code> 的去重和索引管理则会出现：<strong>冗余巨大、索引混乱、实现复杂</strong></p>
<table>
<thead>
<tr>
<th align="left">类</th>
<th align="left">角色</th>
<th align="left">核心职责</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><code>Symbol</code></strong></td>
<td align="left"><strong>常量池条目的“内存对象”</strong></td>
<td align="left">封装一个常量池条目（如 <code>CONSTANT_Class_info</code>, <code>CONSTANT_Utf8_info</code>）的所有信息（类型、值、哈希码、索引等）。它是 <code>SymbolTable</code> 操作的基本单位。</td>
</tr>
<tr>
<td align="left"><strong><code>SymbolTable</code></strong></td>
<td align="left"><strong>常量池的“中央仓库”与“去重器”</strong></td>
<td align="left">管理一个 <code>ClassWriter</code> 中所有 <code>Symbol</code> 对象的集合。其核心任务是：<strong>添加新条目时检查是否已存在相同条目，确保常量池中每个值是唯一的，并自动为每个条目分配最终写入文件时的索引。</strong></td>
</tr>
</tbody></table>
</li>
<li><p><strong>Type</strong>、<strong>TypePath</strong> 和 <strong>TypeReference</strong><br>在ASM中，**<code>Type</code>、<code>TypePath</code> 和 <code>TypeReference</code> 是三个紧密协作、专门用于精确描述和操作 Java 类型系统（特别是泛型）的类**<br>简单来说:<br>(1)<strong><code>Type</code></strong> 是描述 <strong>“是什么类型”</strong> 的基础工具（如 <code>List&lt;String&gt;</code>）,是ASM中对Java类型（包括泛型）的<strong>高级、面向对象的封装</strong><br>(2)<strong><code>TypePath</code></strong> 是描述在嵌套类型中 <strong>“具体指向哪个部分”</strong> 的导航工具（如 <code>List&lt;String&gt;</code> 中的 <code>String</code>）,是在嵌套类型中的“导航路径”<br>(3)<strong><code>TypeReference</code></strong> 是标识 <strong>“类型信息出现在哪个具体上下文”</strong> 的定位工具（如在方法的哪个类型参数上），是类型上下文的“定位标签”<br>它们共同使得ASM能够精确地读取、修改和生成包含复杂泛型、嵌套类型和位置敏感注解的Java字节码，这是实现高级代码分析、增强和生成工具（如Lombok、MapStruct）的关键</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">flowchart TD</span><br><span class="line">    A[&quot;复杂类型: Map&lt;String, List&lt;Thread&gt;&gt;&quot;] --&gt; B</span><br><span class="line"></span><br><span class="line">    subgraph B [ASM解析过程]</span><br><span class="line">        B1[&quot;Type: 获取整体类型描述符&lt;br/&gt;Ljava/util/Map&lt;...&gt;;&quot;]</span><br><span class="line">        B2[&quot;TypeReference: 定位注解位置&lt;br/&gt;如 FIELD 或 TYPE_ARGUMENT(1)&quot;]</span><br><span class="line">        B3[&quot;TypePath: 导航至具体嵌套类型&lt;br/&gt;如 &#x27;1;&#x27; 指向 List&lt;Thread&gt;&quot;]</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    B --&gt; C&#123;“需要操作?”&#125;</span><br><span class="line">    C --&gt;|修改/读取| D[协同工作]</span><br><span class="line">    C --&gt;|仅描述| E[“主要使用 Type”]</span><br><span class="line"></span><br><span class="line">    D --&gt; F[“示例: 读取/修改&lt;br&gt;List&lt;Thread&gt; 上的注解”]</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>ClassTooLargeException</strong> 和 <strong>MethodTooLargeException</strong><br>在ASM中，**<code>ClassTooLargeException</code> 和 <code>MethodTooLargeException</code> 是两个特殊的 <code>RuntimeException</code> 子类<strong>，</strong>当ASM尝试生成的字节码超出JVM规范允许的硬性限制时，主动抛出异常，提前告知开发者，而不是生成一个无效的、无法被JVM加载的 <code>.class</code> 文件**</p>
<table>
<thead>
<tr>
<th align="left">异常</th>
<th align="left">触发条件</th>
<th align="left">对应的JVM规范限制</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><code>ClassTooLargeException</code></strong></td>
<td align="left">生成的<strong>整个类文件</strong>的字节数超过 <code>65535</code>（即 <code>0xFFFF</code>）。</td>
<td align="left"><code>.class</code> 文件的 <code>u4</code>（无符号4字节）总长度字段最大为 <code>0xFFFF</code>。实际上，由于常量池等开销，有效内容上限比这个略小。</td>
</tr>
<tr>
<td align="left"><strong><code>MethodTooLargeException</code></strong></td>
<td align="left">生成的<strong>单个方法</strong>的 <code>Code</code> 属性大小超过 <code>65535</code> 字节。</td>
<td align="left"><code>Code</code> 属性中的 <code>code_length</code> 项是一个 <code>u4</code> 类型，但规范明确规定其值必须小于 <code>65536</code></td>
</tr>
</tbody></table>
</li>
</ol>
<p>如果没有这两个异常，ASM会“忠实”地生成一个超大的类文件。当你试图用 <code>ClassLoader</code> 加载它时，JVM会抛出一个更底层、更晦涩的 <code>ClassFormatError</code></p>
<h2 id="1-2core包：核心工具和基础接口"><a href="#1-2core包：核心工具和基础接口" class="headerlink" title="1.2core包：核心工具和基础接口"></a>1.2core包：核心工具和基础接口</h2><p>该包中包含以下子包：annotation、codec、convert、env、io、log、metrics、serializer、style、task、type，以及根目录的一些java文件</p>
<table>
<thead>
<tr>
<th>分层名称</th>
<th>包含包 &#x2F; 目录</th>
<th>核心职责</th>
</tr>
</thead>
<tbody><tr>
<td>基础工具层（核心根基）</td>
<td>根目录、log 包</td>
<td>提供框架最基础的工具类（版本、异常、泛型解析）+ 统一日志适配，是所有能力的根基</td>
</tr>
<tr>
<td>类型与注解处理层</td>
<td>type 包、annotation 包、convert 包</td>
<td>封装 “类型解析、注解操作、类型转换” 三大核心能力，支撑 beans&#x2F;context 的属性绑定、注解驱动</td>
</tr>
<tr>
<td>环境与资源支撑层</td>
<td>env 包、io 包</td>
<td>提供 “配置环境抽象（env）” 和 “统一资源访问（io）”，支撑配置加载、资源定位（如 classpath 资源）</td>
</tr>
<tr>
<td>数据编解码与格式化层</td>
<td>codec 包、serial 包、style 包</td>
<td>处理 “对象↔字节流（serial）”、“数据↔编码（codec）”、“对象↔字符串（style）” 的转换 &#x2F; 格式化</td>
</tr>
<tr>
<td>任务与度量支撑层</td>
<td>task 包、metrics 包</td>
<td>提供任务执行 &#x2F; 调度的基础接口、简单度量能力，为上层（如 spring-context 的任务调度）铺垫</td>
</tr>
</tbody></table>
<h3 id="（1）类型与注解处理层"><a href="#（1）类型与注解处理层" class="headerlink" title="（1）类型与注解处理层"></a>（1）类型与注解处理层</h3><h4 id="1-annotation包：发现和处理注解信息"><a href="#1-annotation包：发现和处理注解信息" class="headerlink" title="1.annotation包：发现和处理注解信息"></a>1.<strong>annotation</strong>包：发现和处理注解信息</h4><p>提供注解扫描、解析、合并和处理的工具类，是Spring注解驱动编程的基础</p>
<p>该包下的java文件可分为5类：<strong>核心元数据类</strong>、<strong>注解扫描与收集类</strong>、<strong>注解属性处理类</strong>、<strong>注解过滤器与选择器类</strong>、<strong>特殊用途工具类</strong></p>
<h5 id="1-1核心元数据类"><a href="#1-1核心元数据类" class="headerlink" title="1.1核心元数据类"></a>1.1核心元数据类</h5><p>（2）<strong>AnnotationUtils</strong> 和 <strong>AnnotatedElementUtils</strong></p>
<table>
<thead>
<tr>
<th>对比维度</th>
<th>AnnotationUtils</th>
<th>AnnotatedElementUtils</th>
</tr>
</thead>
<tbody><tr>
<td><strong>核心定位</strong></td>
<td>原生注解工具：处理 “直接标注” 的注解，操作轻量</td>
<td>注解合并工具：处理 “注解继承 &#x2F; 聚合”，自动合并属性</td>
</tr>
<tr>
<td><strong>默认查找范围</strong></td>
<td>仅找「直接标注」的注解（类 &#x2F; 方法上直接贴的）</td>
<td>自动找「直接注解 + 元注解 + 父类 &#x2F; 接口注解」</td>
</tr>
<tr>
<td><strong>@AliasFor 支持</strong></td>
<td>不支持：仅读取原始属性，不合并别名 &#x2F; 覆盖的属性</td>
<td>完全支持：自动解析 @AliasFor，合并覆盖后的属性</td>
</tr>
<tr>
<td><strong>属性合并能力</strong></td>
<td>无：元注解属性和组合注解属性独立，不合并</td>
<td>有：自动合并元注解、组合注解的属性（取覆盖值）</td>
</tr>
<tr>
<td><strong>父类 &#x2F; 接口注解处理</strong></td>
<td>不支持：仅处理当前元素的注解，忽略父类 &#x2F; 接口</td>
<td>支持：自动扫描父类 &#x2F; 接口的注解并合并</td>
</tr>
<tr>
<td><strong>典型设计目标</strong></td>
<td>性能优先，轻量操作</td>
<td>功能优先，完整处理注解语义</td>
</tr>
<tr>
<td><strong>核心方法示例</strong></td>
<td><code>findAnnotation()</code>、<code>getAnnotationAttributes()</code></td>
<td><code>findMergedAnnotation()</code>、<code>findAllMergedAnnotations()</code></td>
</tr>
</tbody></table>
<h5 id="1-2扫描与元数据采集"><a href="#1-2扫描与元数据采集" class="headerlink" title="1.2扫描与元数据采集"></a>1.2扫描与元数据采集</h5><p>（1）<strong>AnnotationsScanner</strong> 和 <strong>AnnotationsProcessor</strong></p>
<p>二者配置使用，扫描注解，AnnotationsProcessor中有两个方法<strong>doWithAggregate()</strong> 和 <strong>doWithAnnotations()</strong>:</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>核心逻辑（5.3.8 精准版）</th>
<th>关键特点</th>
</tr>
</thead>
<tbody><tr>
<td><code>doWithAggregate</code></td>
<td>聚合单元<strong>处理前</strong>的前置回调，仅接收 “上下文 + 单元索引”，无具体注解</td>
<td>1. 默认方法，可选实现；2. 无注解信息，仅做 “预判 &#x2F; 准备”；3. 返回非 null 可短路<strong>当前单元</strong>的注解处理；</td>
</tr>
<tr>
<td><code>doWithAnnotations</code></td>
<td>聚合单元<strong>核心处理</strong>，接收 “上下文 + 索引 + 来源 + 注解数组”，处理具体注解</td>
<td>1. 抽象方法，必须实现；2. 有完整注解信息，可遍历处理单个注解；3. 返回非 null 可短路<strong>整个扫描流程</strong>；</td>
</tr>
</tbody></table>
<p>其中**doWithAggregate()**方法的作用: 提前预判是否需要进行后续操作(doWithAnnotations扫描注解)，优化性能（若是提前终止，则无需进行后续注解的扫描）</p>
<h5 id="1-3注解属性处理以及合并"><a href="#1-3注解属性处理以及合并" class="headerlink" title="1.3注解属性处理以及合并"></a>1.3注解属性处理以及合并</h5><p>（1）<strong>AnnotationAttributes</strong></p>
<p>封装注解的属性值，继承了LinkedHashMap&lt;String, Object&gt;</p>
<p>（2）<strong>AttributeMethods</strong></p>
<p><strong>封装注解类型的 “属性方法” 元数据</strong>（注解接口的抽象方法即为注解的属性），提供高效的属性方法查找、遍历、校验能力，是 Spring 注解属性提取 &#x2F; 解析的底层基础类，简单说：注解的 “属性” 本质是注解接口的抽象方法（如 <code>@RootAnno</code> 的 <code>String value()</code>），<code>AttributeMethods</code> 就是专门管理这些 “属性方法” 的工具 —— 它帮上层注解处理类（如 <code>TypeMappedAnnotation</code>&#x2F;<code>MergedAnnotation</code>）快速找到注解的属性方法、避免重复反射解析，提升性能和规范性</p>
<p>作用：主要在解析注解属性的过程中发挥作用，是 <code>TypeMappedAnnotation</code>&#x2F;<code>MergedAnnotation</code> 等类解析注解属性的底层依赖</p>
<ul>
<li><p>统一解析合法属性方法：自动过滤掉非属性方法，只保留符合注解规范的抽象方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例：@RootAnno 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RootAnno &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;root-default&quot;</span>; <span class="comment">// 合法属性方法</span></span><br><span class="line">    <span class="keyword">default</span> String <span class="title function_">desc</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="string">&quot;desc&quot;</span>; &#125; <span class="comment">// 默认方法（过滤）</span></span><br><span class="line">    String <span class="title function_">toString</span><span class="params">()</span>; <span class="comment">// Object 继承的方法（过滤）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析 @RootAnno 的属性方法</span></span><br><span class="line"><span class="type">AttributeMethods</span> <span class="variable">methods</span> <span class="operator">=</span> AttributeMethods.forAnnotationType(RootAnno.class);</span><br><span class="line">System.out.println(methods.size()); <span class="comment">// 输出 1（仅保留 value() 方法）</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>缓存复用，避免重复反射:每个注解类型的 <code>AttributeMethods</code> 实例只会解析一次，缓存到静态 Map 中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一次调用：反射解析 + 缓存</span></span><br><span class="line"><span class="type">AttributeMethods</span> <span class="variable">m1</span> <span class="operator">=</span> AttributeMethods.forAnnotationType(RootAnno.class);</span><br><span class="line"><span class="comment">// 第二次调用：直接从缓存取，无反射</span></span><br><span class="line"><span class="type">AttributeMethods</span> <span class="variable">m2</span> <span class="operator">=</span> AttributeMethods.forAnnotationType(RootAnno.class);</span><br><span class="line">System.out.println(m1 == m2); <span class="comment">// 输出 true（同一实例）</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>高效按属性名查找方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AttributeMethods</span> <span class="variable">methods</span> <span class="operator">=</span> AttributeMethods.forAnnotationType(RootAnno.class);</span><br><span class="line"><span class="comment">// 快速获取 value 属性的方法</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">valueMethod</span> <span class="operator">=</span> methods.get(<span class="string">&quot;value&quot;</span>);</span><br><span class="line"><span class="comment">// 判断是否存在 name 属性</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">hasName</span> <span class="operator">=</span> methods.has(<span class="string">&quot;name&quot;</span>); <span class="comment">// 输出 false</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>（3）<strong>ValueExtractor</strong></p>
<p><strong>抽象并标准化 <code>MergedAnnotation</code> 的属性值提取逻辑</strong>，<strong>为 <code>MergedAnnotation</code> 提供「类型化的属性值提取逻辑」</strong> —— 定义了 “从 <code>MergedAnnotation</code> 中提取指定类型属性值” 的标准规则，是 <code>MergedAnnotation</code> 能便捷提供 <code>getInt()</code>&#x2F;<code>getString()</code>&#x2F;<code>getEnum()</code> 等类型化取值方法的底层支撑</p>
<p>（4）<strong>TypeMappedAnnotation</strong> 和 <strong>TypeMappedAnnotations</strong></p>
<p>TypeMappedAnnotation：封装<strong>单个原始注解的 “实例 + 类型映射元数据”</strong>（原始注解对象、来源、@AliasFor 解析、元注解关联），是 Spring 扫描注解的 “最小原子载体”</p>
<p>TypeMappedAnnotations：管理<strong>多个 <code>TypeMappedAnnotation</code> 的容器 &#x2F; 扫描器</strong>，负责从目标元素（类 &#x2F; 方法）扫描所有注解（直接 + 元注解）、缓存扫描结果，是上层注解处理类的 “数据源”</p>
<p>虽然TypeMappedAnnotation继承了AbstractMergedAnnotation类，但是并没有实现具体的合并注解的逻辑，只是为了和MergedAnnotation结构保持统一，上层的 <code>MergedAnnotations</code> 只需面向 <code>MergedAnnotation</code> 接口编程，无需区分 “原始注解载体（TypeMappedAnnotation）” 和 “合并注解实例（StandardMergedAnnotation）”—— 前者提供原始数据，后者基于前者的数据做合并，上层代码感知不到差异</p>
<p>（5）<strong>AnnotationTypeMappings</strong> 和 <strong>AnnotationTypeMapping</strong></p>
<p>负责处理注解类型的映射和属性别名解析，主要是<strong>AnnotatedElementUtils</strong>使用其处理注解合并（<strong>AnnotationUtils</strong>不处理注解合并的情况）</p>
<p>AnnotationTypeMappings:映射集合容器, AnnotationTypeMapping则为容器中的单个映射项</p>
<p><strong>AnnotationTypeMapping</strong>封装单个注解的信息：属性别名、元注解关联、属性映射规则等</p>
<p>其中<strong>AnnotationTypeMappings</strong>通过<strong>forAnnotationType(Class&lt;? extends Annotation&gt; annotationType)<strong>为给定的注解构建</strong>完整的注解类型映射链</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationTypeMapping</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; annotationType; <span class="comment">// 注解类型（如ComboAnno/RootAnno）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, String&gt; attributeAliasMap; <span class="comment">// 属性别名映射（如name→value）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AnnotationTypeMapping parent; <span class="comment">// 父映射项（如RootAnno是ComboAnno的父）</span></span><br><span class="line">    <span class="comment">// ... 其他辅助字段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取ComboAnno的第一个映射项（ComboAnno自身）</span></span><br><span class="line"><span class="type">AnnotationTypeMapping</span> <span class="variable">comboMapping</span> <span class="operator">=</span> mappings.get(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 获取属性别名映射</span></span><br><span class="line">Map&lt;String, String&gt; aliasMap = comboMapping.getAttributeAliasMap();</span><br><span class="line"><span class="comment">// 输出：name → value（ComboAnno的name属性对应RootAnno的value属性）</span></span><br><span class="line">System.out.println(aliasMap.get(<span class="string">&quot;name&quot;</span>)); <span class="comment">// 输出 &quot;value&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//AnnotationTypeMappings的构造方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">AnnotationTypeMappings</span><span class="params">(RepeatableContainers repeatableContainers,</span></span><br><span class="line"><span class="params">			AnnotationFilter filter, Class&lt;? extends Annotation&gt; annotationType)</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">this</span>.repeatableContainers = repeatableContainers;</span><br><span class="line">		<span class="built_in">this</span>.filter = filter;</span><br><span class="line">		<span class="built_in">this</span>.mappings = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		addAllMappings(annotationType);		<span class="comment">//通过addAllMappings 添加 annotationType 对应的AnnotationTypeMapping</span></span><br><span class="line">		<span class="built_in">this</span>.mappings.forEach(AnnotationTypeMapping::afterAllMappingsSet);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//addAllMappings</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addAllMappings</span><span class="params">(Class&lt;? extends Annotation&gt; annotationType)</span> &#123;</span><br><span class="line">    Deque&lt;AnnotationTypeMapping&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    addIfPossible(queue, <span class="literal">null</span>, annotationType, <span class="literal">null</span>); <span class="comment">//将给定注解构造成 AnnotationTypeMapping 并添加到mappings</span></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">AnnotationTypeMapping</span> <span class="variable">mapping</span> <span class="operator">=</span> queue.removeFirst();</span><br><span class="line">        <span class="built_in">this</span>.mappings.add(mapping);</span><br><span class="line">        addMetaAnnotationsToQueue(queue, mapping); <span class="comment">//扫描当前注解的元注解，并构造元注解对应的 AnnotationTypeMapping，然后添加到mappings</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//addIfPossible</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addIfPossible</span><span class="params">(Deque&lt;AnnotationTypeMapping&gt; queue, <span class="meta">@Nullable</span> AnnotationTypeMapping source,</span></span><br><span class="line"><span class="params">        Class&lt;? extends Annotation&gt; annotationType, <span class="meta">@Nullable</span> Annotation ann)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        queue.addLast(<span class="keyword">new</span> <span class="title class_">AnnotationTypeMapping</span>(source, annotationType, ann)); <span class="comment">//构造给定注解的AnnotationTypeMapping，并添加到队列</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        AnnotationUtils.rethrowAnnotationConfigurationException(ex);</span><br><span class="line">        <span class="keyword">if</span> (failureLogger.isEnabled()) &#123;</span><br><span class="line">            failureLogger.log(<span class="string">&quot;Failed to introspect meta-annotation &quot;</span> + annotationType.getName(),</span><br><span class="line">                    (source != <span class="literal">null</span> ? source.getAnnotationType() : <span class="literal">null</span>), ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用Deque（双端队列）代替递归扫描元注解，避免栈溢出（队列使用的是堆内存，递归栈的大小受jvm参数的控制，一般来说堆内存比栈内存大得多）</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>维度</th>
<th>TypeMappedAnnotation</th>
<th>AnnotationTypeMapping</th>
</tr>
</thead>
<tbody><tr>
<td>粒度</td>
<td>「注解实例级」：绑定<strong>具体的注解实例</strong>（如类 A 上的 <code>@ComboAnno(name=&quot;a&quot;)</code>）</td>
<td>「注解类型级」：绑定<strong>注解类型</strong>（如 <code>ComboAnno.class</code>），与具体实例无关</td>
</tr>
<tr>
<td>存储内容</td>
<td>实例数据（注解实例、来源类、是否直接注解）+ 类型元数据（@AliasFor、元注解）</td>
<td>纯类型规则（注解类型链路、@AliasFor 别名映射、元注解类型关联）</td>
</tr>
<tr>
<td>复用性</td>
<td>不可复用（每个实例对应一个 TMA）</td>
<td>可复用（同一注解类型的所有实例共享同一 ATM 规则）</td>
</tr>
<tr>
<td>核心职责</td>
<td>封装 “原始注解实例 + 全量元数据”</td>
<td>封装 “注解类型间的映射规则”</td>
</tr>
</tbody></table>
<p>:bulb:<code>TypeMappedAnnotation记录的是注解的全量信息，而AnnotationTypeMapping更聚焦“规则”而不是实例，而MergedAnnotation只需根据AnnotationTypeMapping的规则合并数据即可</code></p>
<p>（6）<strong>MergedAnnotation</strong> 和 <strong>MissingMergedAnnotation</strong> 和 <strong>MergedAnnotations</strong> 和 <strong>AbstractMergedAnnotation</strong> 和 <strong>MergedAnnotationsCollection</strong></p>
<p>MergedAnnotation：封装<strong>单个注解合并后的完整信息</strong>（包括属性、元注解关联、@AliasFor 解析结果、注解来源等），是 “合并后注解的最小操作单元”</p>
<p>MissingMergedAnnotation：<strong>作为 “缺失的合并注解” 的占位符实例</strong>—— 当尝试获取某个不存在的注解（如 <code>MergedAnnotations.get(NonExistentAnno.class)</code>）时，不返回 <code>null</code>，而是返回这个预定义的单例，避免空指针异常（NPE），同时统一 “注解缺失” 场景的处理逻辑，简单说：它是 <code>MergedAnnotation</code> 的 “空对象（Null Object）” 实现 —— 用一个合法的、无意义的实例替代 <code>null</code>，让上层代码无需频繁判空，直接调用 <code>MergedAnnotation</code> 的方法（如 <code>isPresent()</code>&#x2F;<code>getString()</code>）即可</p>
<p>MergedAnnotations：管理<strong>多个 <code>MergedAnnotation</code> 的容器 &#x2F; 管理器</strong>，提供查找、遍历、判断存在性等批量操作，是 Spring 获取 “合并注解” 的统一入口</p>
<p>AbstractMergedAnnotation：MergedAnnotation的实现抽象类，<strong>抽离所有 <code>MergedAnnotation</code> 实现类的通用核心逻辑（如懒加载属性解析、@AliasFor 映射、来源追溯、类型安全转换），对接底层 <code>AnnotationTypeMappings</code> 规则，为子类提供统一的基础能力，同时定义子类需实现的抽象规范</strong>，是 Spring 注解处理中 “空安全” 的核心设计</p>
<p>MergedAnnotationsCollection：<code>MergedAnnotations</code> 接口的 “底层实现容器”,用于存放MergedAnnotation数据，且存放的数据为只读，不可修改</p>
<p>两者是<strong>AnnotatedElementUtils</strong>类中合并注解的底层实现，在合并的过程中依赖<strong>AnnotationTypeMapping</strong>提供的注解映射规则（AnnotationTypeMapping形成的是一条注解链信息，MergedAnnotation会遍历注解链，获取属性值，后一个覆盖前一个，直至遍历完成得到最终的属性值），基于这些规则最终封装出合并后的注解结果</p>
<p><code>AnnotationTypeMappings</code> 是 <code>MergedAnnotation</code> 的 “底层规则引擎”，负责解析注解的层级关系和别名规则；<code>MergedAnnotation</code>&#x2F;<code>MergedAnnotations</code> 是基于这些规则的 “顶层结果封装”，对外提供简洁的合并注解操作</p>
<table>
<thead>
<tr>
<th>层级</th>
<th>核心类</th>
<th>核心职责</th>
</tr>
</thead>
<tbody><tr>
<td>底层扫描层</td>
<td>TypeMappedAnnotation&#x2F;TypeMappedAnnotations</td>
<td>扫描原始注解，封装为原子单元，提供数据源</td>
</tr>
<tr>
<td>规则解析层</td>
<td>AnnotationTypeMappings&#x2F;AnnotationTypeMapping</td>
<td>构建注解类型映射链，解析 @AliasFor 规则</td>
</tr>
<tr>
<td>结果合并层</td>
<td>MergedAnnotation&#x2F;MergedAnnotations</td>
<td>合并属性，封装对外的合并注解结果</td>
</tr>
</tbody></table>
<p>（7）<strong>RepeatableContainers</strong></p>
<p><strong>封装「可重复注解（@Repeatable）」与「容器注解」的映射规则</strong>，统一处理 Java 原生可重复注解的解析，同时支持自定义可重复注解的容器映射，是 Spring 扫描 &#x2F; 解析可重复注解的核心规则管理器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可重复注解（标注 @Repeatable，指定容器注解 RootAnnos）</span></span><br><span class="line"><span class="meta">@Repeatable(RootAnnos.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RootAnno &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 容器注解（包含 RootAnno[] 类型的 value 属性）</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RootAnnos &#123;</span><br><span class="line">    RootAnno[] value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 业务类：标注多个 @RootAnno</span></span><br><span class="line"><span class="meta">@RootAnno(&quot;first&quot;)</span></span><br><span class="line"><span class="meta">@RootAnno(&quot;second&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnoTest</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>Java 原生解析时，多个 <code>@RootAnno</code> 会被封装到 <code>@RootAnnos</code> 中，需手动从容器注解中提取单个注解实例 —— 而 <code>RepeatableContainers</code> 就是 Spring 为简化这一过程设计的工具</p>
<p>示例1：解析 Java 原生可重复注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 获取默认的 RepeatableContainers 实例</span></span><br><span class="line"><span class="type">RepeatableContainers</span> <span class="variable">containers</span> <span class="operator">=</span> RepeatableContainers.standard();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 从 AnnoTest 类中查找所有 @RootAnno 实例（自动拆分 @RootAnnos 容器）</span></span><br><span class="line">List&lt;RootAnno&gt; repeatedAnnos = containers.findRepeatedAnnotations(AnnoTest.class, RootAnno.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 输出结果：包含 &quot;first&quot; 和 &quot;second&quot; 两个实例</span></span><br><span class="line">System.out.println(repeatedAnnos.size()); <span class="comment">// 输出 2</span></span><br><span class="line">System.out.println(repeatedAnnos.get(<span class="number">0</span>).value()); <span class="comment">// 输出 &quot;first&quot;</span></span><br><span class="line">System.out.println(repeatedAnnos.get(<span class="number">1</span>).value()); <span class="comment">// 输出 &quot;second&quot;</span></span><br></pre></td></tr></table></figure>

<p>示例2:添加自定义可重复注解映射</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义可重复注解（不使用原生 @Repeatable 注解，而是自定义）</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CustomAnno &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义容器注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CustomAnnos &#123;</span><br><span class="line">    CustomAnno[] value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 创建自定义 RepeatableContainers 实例，添加映射</span></span><br><span class="line"><span class="type">RepeatableContainers</span> <span class="variable">customContainers</span> <span class="operator">=</span> RepeatableContainers.standard()</span><br><span class="line">        .with(CustomAnno.class, CustomAnnos.class); <span class="comment">// 手动关联可重复注解和容器注解，若是不关联，则无法识别自定义的容器注解（只认识原生 @Repeatable 容器注解）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 查找 CustomAnno 实例（即使无 @Repeatable，也能拆分容器注解）</span></span><br><span class="line">List&lt;CustomAnno&gt; customAnnos = customContainers.findRepeatedAnnotations(AnnoTest.class, CustomAnno.class);</span><br></pre></td></tr></table></figure>

<p>自定义可重复注解映射的核心是：<strong>通过 <code>RepeatableContainers.with()</code> 手动告诉 Spring「哪个注解是可重复的，哪个注解是它的容器」</strong></p>
<p>（8）<strong>SynthesizedAnnotation</strong> 和 <strong>SynthesizedMergedAnnotationInvocationHandler</strong> 和 <strong>SynthesizingMethodParameter</strong></p>
<p>SynthesizedAnnotation：<strong>标识一个注解实例是「Spring 合成的注解实例」（而非 JVM 原生反射生成的注解实例）</strong>，用于区分注解实例的来源，是 Spring 注解处理中 “注解实例来源标识” 的核心接口</p>
<table>
<thead>
<tr>
<th>注解实例来源</th>
<th>生成方式</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>JVM 原生注解实例</td>
<td>通过 <code>Class.getAnnotation()</code> 等反射 API 获取</td>
<td>由 JVM 动态代理生成，只读、不可修改属性值，仅返回注解标注时的原始值 &#x2F; 默认值</td>
</tr>
<tr>
<td>Spring 合成注解实例</td>
<td>通过 Spring 工具类（如 <code>AnnotationUtils</code>）生成</td>
<td>Spring 手动创建的代理实例，可动态修改属性值（如合并组合注解的属性）</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 定义组合注解和元注解（复用之前的示例）</span></span><br><span class="line"><span class="meta">@RootAnno</span> <span class="comment">// 元注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ComboAnno &#123;</span><br><span class="line">    <span class="meta">@AliasFor(annotation = RootAnno.class, attribute = &quot;value&quot;)</span></span><br><span class="line">    String <span class="title function_">name</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RootAnno &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;root-default&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 业务类标注组合注解</span></span><br><span class="line"><span class="meta">@ComboAnno(name = &quot;test-class&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnoTest</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 测试合成注解与标识</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 步骤1：获取 JVM 原生的 ComboAnno 实例（无 SynthesizedAnnotation 标识）</span></span><br><span class="line">        <span class="type">ComboAnno</span> <span class="variable">nativeComboAnno</span> <span class="operator">=</span> AnnoTest.class.getAnnotation(ComboAnno.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;原生 ComboAnno 是否合成：&quot;</span> + (nativeComboAnno <span class="keyword">instanceof</span> SynthesizedAnnotation)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 步骤2：提取 ComboAnno 的属性（name=&quot;test-class&quot;），映射为 RootAnno 的 value 属性</span></span><br><span class="line">        Map&lt;String, Object&gt; attributes = AnnotationUtils.getAnnotationAttributes(nativeComboAnno);</span><br><span class="line">        <span class="comment">// 把 ComboAnno 的 name 属性映射为 RootAnno 的 value 属性</span></span><br><span class="line">        attributes.put(<span class="string">&quot;value&quot;</span>, attributes.get(<span class="string">&quot;name&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 步骤3：Spring 合成 RootAnno 实例（实现 SynthesizedAnnotation）</span></span><br><span class="line">        <span class="type">RootAnno</span> <span class="variable">synthesizedRootAnno</span> <span class="operator">=</span> AnnotationUtils.synthesizeAnnotation(attributes, RootAnno.class, AnnoTest.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;合成 RootAnno 是否合成：&quot;</span> + (synthesizedRootAnno <span class="keyword">instanceof</span> SynthesizedAnnotation)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;合成 RootAnno 的 value：&quot;</span> + synthesizedRootAnno.value()); <span class="comment">// 输出 &quot;test-class&quot;（合并后的值）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 步骤4：对比 JVM 原生 RootAnno 实例（如果直接获取，是默认值）</span></span><br><span class="line">        <span class="type">RootAnno</span> <span class="variable">nativeRootAnno</span> <span class="operator">=</span> AnnoTest.class.getAnnotation(RootAnno.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;原生 RootAnno 的 value：&quot;</span> + (nativeRootAnno == <span class="literal">null</span> ? <span class="string">&quot;null&quot;</span> : nativeRootAnno.value())); <span class="comment">// null（AnnoTest 未直接标注 @RootAnno）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要是在合并注解的过程中发挥作用：spring在获取某个注解时，会自动处理组合注解的层级关系以及@AliasFor的属性映射关系，比如上述例子中**@ComboAnno<strong>是一个组合注解，同时将</strong>@ComboAnno<strong>中的属性值<code>name</code>映射到元注解</strong>@RootAnno<strong>的属性值<code>value</code>上，因此，若是想要获取</strong>@RootAnno<strong>注解的信息，肯定是需要处理属性值的映射，最终获取</strong>@RootAnno<strong>中的属性</strong>value<strong>的值应该是</strong>test-class<strong>，但是传统获取注解信息的方法</strong>AnnoTest.class.getAnnotation(RootAnno.class)**无法处理注解层级结构以及属性值映射，所以Spring直接帮我们处理注解的层级关系以及属性值的映射，同时将结果封装成一个合成注解（通过SynthesizedMergedAnnotationInvocationHandler实现）并返回，让我们能够以正常获取注解的方法使用合成注解（获取注解信息，以及属性值）而无需在意具体的处理细节。</p>
<p>SynthesizedMergedAnnotationInvocationHandler：封装合成注解的具体实现与SynthesizedAnnotation共同构成<strong>合成注解</strong>，<strong>JDK 动态代理的 <code>InvocationHandler</code> 实现类</strong>，专门负责处理「合成注解实例（实现 <code>SynthesizedAnnotation</code>）」的方法调用 —— 当你调用合成注解的属性方法（如 <code>anno.value()</code>）时，正是这个处理器拦截调用、返回 Spring 预先合并后的属性值，而非原生注解的默认值 &#x2F; 直接标注值；</p>
<p>当调用 <code>MergedAnnotation.synthesize()</code> 时，Spring 会：</p>
<ol>
<li>创建 <code>SynthesizedMergedAnnotationInvocationHandler</code> 实例（绑定当前 <code>MergedAnnotation</code>）；</li>
<li>通过<code>Proxy.newProxyInstance()</code>生成动态代理实例：<ul>
<li>代理类实现的接口：<code>RootAnno</code>（原注解） + <code>SynthesizedAnnotation</code>（标记）；</li>
<li>代理类的 InvocationHandler：上述创建的 <code>SynthesizedMergedAnnotationInvocationHandler</code>；</li>
</ul>
</li>
<li>返回这个代理实例（即开发者拿到的 <code>synthesizedRoot</code>）</li>
</ol>
<p>通过拦截对应方法获取合成注解的最终属性值（实际还是调用的MergedAnnotation中的getValue方法）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简化版 invoke 方法（还原核心逻辑）</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">// 1. 处理 Object 类的通用方法（toString/hashCode/equals）</span></span><br><span class="line">    <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;toString&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;SynthesizedAnnotation[&quot;</span> + <span class="built_in">this</span>.mergedAnnotation.getAnnotationType().getName() + <span class="string">&quot;, attributes=&quot;</span> + <span class="built_in">this</span>.mergedAnnotation.asMap() + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;hashCode&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.mergedAnnotation.hashCode();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;equals&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.mergedAnnotation.equals(args[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 处理注解的默认方法（接口默认实现）</span></span><br><span class="line">    <span class="keyword">if</span> (method.isDefault()) &#123;</span><br><span class="line">        <span class="keyword">return</span> InvocationHandler.invokeDefault(proxy, method, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 处理注解的属性方法（核心：返回合并后的属性值）</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">attributeName</span> <span class="operator">=</span> method.getName();</span><br><span class="line">    <span class="comment">// 从 MergedAnnotation 中获取合并后的属性值（比如 &quot;test-class&quot;）</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> <span class="built_in">this</span>.mergedAnnotation.getValue(attributeName).orElseGet(() -&gt; &#123;</span><br><span class="line">        <span class="comment">// 兜底：返回注解的默认值（如果合并值不存在）</span></span><br><span class="line">        <span class="keyword">return</span> method.getDefaultValue();</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SynthesizingMethodParameter：扩展MethodParameter的功能，是 Spring 对「方法 &#x2F; 构造器参数」的增强封装 —— 核心作用是为方法参数提供「注解合成能力」，解决普通 <code>MethodParameter</code> 无法处理参数级注解合并（如 <code>@AliasFor</code>、元注解继承）的问题，确保参数上的注解能像类 &#x2F; 方法注解一样返回合成后的最终属性值，是「合成注解」能力在「方法参数」维度的落地</p>
<h5 id="1-4注解过滤器与选择器类"><a href="#1-4注解过滤器与选择器类" class="headerlink" title="1.4注解过滤器与选择器类"></a>1.4注解过滤器与选择器类</h5><p>（1）<strong>MergedAnnotationSelector</strong> 和 <strong>MergedAnnotationSelectors</strong></p>
<p>MergedAnnotationSelector：策略模式接口，<strong>定义 “从多个候选 <code>MergedAnnotation</code> 实例中选择最优一个” 的规则</strong> ，当目标元素（类 &#x2F; 方法）的注解层级中存在多个同类型的 <code>MergedAnnotation</code>（比如子类 + 父类都有 <code>@RootAnno</code>、组合注解 + 元注解都映射为 <code>@RootAnno</code>）时，由 <code>MergedAnnotationSelector</code> 决定最终返回哪一个，是 <code>MergedAnnotations</code> 实现 “精准获取单个合并注解” 的核心配套组件，简单说：<code>MergedAnnotations</code> 负责 “找到所有符合条件的合并注解”，<code>MergedAnnotationSelector</code> 负责 “从这些注解中选一个最合适的”，二者配合实现 “按需获取单个合并注解”</p>
<p>MergedAnnotationSelectors： 封装了最常用的 <code>MergedAnnotationSelector</code> 实现，其中实现了两种选择策略：<code>NEAREST</code>（就近选择） 和 <code>FIRST_DIRECTLY_DECLARED（选择直接声明的一个）</code></p>
<p>（2）<strong>MergedAnnotationCollectors</strong> 和 <strong>MergedAnnotationPredicates</strong></p>
<p>MergedAnnotationCollectors：提供预定义的、类型安全的 <code>java.util.stream.Collector</code> 实现，用于将 <code>MergedAnnotation</code> 的 <code>Stream</code> 流（来自 <code>MergedAnnotations.stream()</code>）收集为各类常用数据结构（如列表、Map、单个注解实例），简化合并注解的流式处理逻辑，简单说：它是 Spring 为 <code>MergedAnnotation</code> 量身定制的「Stream 收集器工具箱」—— 避免开发者重复编写 <code>Collector</code> 来处理注解流，直接复用开箱即用的收集策略</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 构建 MergedAnnotations 容器</span></span><br><span class="line"><span class="type">MergedAnnotations</span> <span class="variable">annotations</span> <span class="operator">=</span> MergedAnnotations.from(AnnoTest.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 示例1：收集为 MergedAnnotation 列表</span></span><br><span class="line">List&lt;MergedAnnotation&lt;RootAnno&gt;&gt; rootAnnoList = annotations.stream(RootAnno.class)</span><br><span class="line">        .collect(MergedAnnotationCollectors.toList());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 示例2：收集为原生 Annotation 列表（合并后的 RootAnno 实例）</span></span><br><span class="line">List&lt;RootAnno&gt; rawRootAnnoList = annotations.stream(RootAnno.class)</span><br><span class="line">        .collect(MergedAnnotationCollectors.toAnnotationList());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 示例3：收集为注解类型→原生 Annotation 的 Map</span></span><br><span class="line">Map&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt;, Annotation&gt; annoMap = annotations.stream()</span><br><span class="line">        .collect(MergedAnnotationCollectors.toAnnotationMap());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 示例4：结合选择器，选最具体的 RootAnno 并转为原生 Annotation</span></span><br><span class="line"><span class="type">RootAnno</span> <span class="variable">mostSpecificRootAnno</span> <span class="operator">=</span> annotations.stream(RootAnno.class)</span><br><span class="line">        .collect(MergedAnnotationCollectors.selecting(MergedAnnotationSelectors.selectMostSpecific()));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 示例5：结合选择器，选第一个 RootAnno 并保留 MergedAnnotation 实例</span></span><br><span class="line">MergedAnnotation&lt;RootAnno&gt; firstRootAnno = annotations.stream(RootAnno.class)</span><br><span class="line">        .collect(MergedAnnotationCollectors.selectingMerged(MergedAnnotationSelectors.selectFirst()));</span><br></pre></td></tr></table></figure>

<p>MergedAnnotationPredicates: 提供预定义的、类型安全的 <code>java.util.function.Predicate</code>（断言）实现，用于过滤 <code>MergedAnnotation</code> 的 <code>Stream</code> 流（来自 <code>MergedAnnotations.stream()</code>），精准筛选符合条件的合并注解（如 “直接标注的注解”“属性值满足条件的注解”“特定类型的注解”），简化注解流的过滤逻辑，简单说：它是 Spring 为 <code>MergedAnnotation</code> 量身定制的「Stream 过滤规则工具箱」—— 避免开发者重复编写 <code>Predicate</code> 来判断注解是否符合条件，直接复用开箱即用的过滤断言</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 构建 MergedAnnotations 容器</span></span><br><span class="line"><span class="type">MergedAnnotations</span> <span class="variable">annotations</span> <span class="operator">=</span> MergedAnnotations.from(AnnoTest.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 示例1：筛选直接标注的 RootAnno 注解</span></span><br><span class="line">List&lt;MergedAnnotation&lt;RootAnno&gt;&gt; directRootAnnos = annotations.stream(RootAnno.class)</span><br><span class="line">        .filter(MergedAnnotationPredicates.direct()) <span class="comment">// 只保留直接注解</span></span><br><span class="line">        .collect(MergedAnnotationCollectors.toList());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 示例2：筛选属性值为 &quot;test-class&quot; 的 RootAnno 注解</span></span><br><span class="line">List&lt;MergedAnnotation&lt;RootAnno&gt;&gt; valueMatchAnnos = annotations.stream(RootAnno.class)</span><br><span class="line">        .filter(MergedAnnotationPredicates.attribute(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;test-class&quot;</span>)) <span class="comment">// 属性值匹配</span></span><br><span class="line">        .collect(MergedAnnotationCollectors.toList());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 示例3：组合规则：直接注解 且 属性值为 &quot;test-class&quot;</span></span><br><span class="line">Predicate&lt;MergedAnnotation&lt;?&gt;&gt; comboPredicate = MergedAnnotationPredicates.direct()</span><br><span class="line">        .and(MergedAnnotationPredicates.attribute(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;test-class&quot;</span>));</span><br><span class="line">List&lt;MergedAnnotation&lt;RootAnno&gt;&gt; comboAnnos = annotations.stream(RootAnno.class)</span><br><span class="line">        .filter(comboPredicate)</span><br><span class="line">        .collect(MergedAnnotationCollectors.toList());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 示例4：筛选存在的、且派生自 RootAnno 的注解</span></span><br><span class="line">List&lt;MergedAnnotation&lt;?&gt;&gt; derivedAnnos = annotations.stream()</span><br><span class="line">        .filter(MergedAnnotationPredicates.present()</span><br><span class="line">                .and(MergedAnnotationPredicates.derivedFrom(RootAnno.class)))</span><br><span class="line">        .collect(MergedAnnotationCollectors.toList());</span><br></pre></td></tr></table></figure>

<p>（3）**AnnotationFilter **和 <strong>PackagesAnnotationFilter</strong></p>
<p>AnnotationFilter ：注解过滤规则，贯穿注解扫描逻辑，过滤一些无需处理的注解（比如java包下的jdk的原始注解**@Target**等）</p>
<p>PackagesAnnotationFilter: AnnotationFilter 的实现类，<strong>基于「注解所在的包」对类进行过滤</strong>（而非注解类型）—— 仅匹配那些 “标注了「指定包下的注解」” 的类，是 Spring 组件扫描（如 <code>@ComponentScan</code>）中 “按注解包维度过滤类” 的核心过滤器</p>
<h5 id="1-5特殊用途工具类"><a href="#1-5特殊用途工具类" class="headerlink" title="1.5特殊用途工具类"></a>1.5特殊用途工具类</h5><p>（1）**OrderUtils **和 <strong>AnnotationAwareOrderComparator</strong></p>
<p>OrderUtils ：<strong>统一提取任意类 &#x2F; 方法 &#x2F; 注解元素的排序优先级</strong>，适配 <code>@Order</code> 和 <code>@Priority</code> 两种排序方式</p>
<p>OrderUtils.getOrder(Class)<code>是获取顺序值的核心方法。它的工作遵循一个清晰的优先级链条：**优先使用</code>@Order<code>注解**，若未找到则尝试查找 Java 标准的</code>@Priority<code>注解，两者都未找到则返回</code>null</p>
<p>AnnotationAwareOrderComparator：是 Spring 排序体系的 <strong>“总协调者”</strong> 和 <strong>“统一入口”</strong>。它的核心职责就是<strong>整合并裁决</strong>多种顺序定义方式，为 Spring 容器中的各种组件（如 Bean、AOP 切面、事件监听器等）提供统一的排序服务</p>
<p>AnnotationAwareOrderComparator的排序过程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">flowchart TD</span><br><span class="line">    A[开始: 为对象查找顺序值] --&gt; B&#123;实例是PriorityOrdered?&#125;</span><br><span class="line">    B -- 是 --&gt; C[标记为最高优先级类别]</span><br><span class="line">    B -- 否 --&gt; D&#123;实例是Ordered?&#125;</span><br><span class="line">    D -- 是 --&gt; E[调用getOrder获取接口顺序值]</span><br><span class="line">    D -- 否 --&gt; F[委托OrderUtils查找注解顺序值]</span><br><span class="line">    C --&gt; G[同样调用getOrder&lt;br&gt;但类别标识不同]</span><br><span class="line">    </span><br><span class="line">    E --&gt; H[得到基于接口的顺序值]</span><br><span class="line">    F --&gt; I[得到基于注解的顺序值 或 null]</span><br><span class="line">    G --&gt; J[得到基于PriorityOrdered接口的顺序值]</span><br><span class="line">    </span><br><span class="line">    H --&gt; K[进入排序比较阶段]</span><br><span class="line">    I --&gt; K</span><br><span class="line">    J --&gt; K</span><br><span class="line">    </span><br><span class="line">    subgraph K[排序比较核心逻辑]</span><br><span class="line">        L&#123;比较两者类别&#125;</span><br><span class="line">        L -- 类别不同 --&gt; M[按类别优先级决定]</span><br><span class="line">        L -- 类别相同 --&gt; N[直接比较order整数值]</span><br><span class="line">        M --&gt; O[得出比较结果 -1, 0, 1]</span><br><span class="line">        N --&gt; O</span><br><span class="line">    end</span><br><span class="line">    </span><br><span class="line">    O --&gt; P[完成排序]</span><br></pre></td></tr></table></figure>

<p>（2）<strong>AnnotationConfigurationException</strong></p>
<p><strong>专门用于标识「注解配置层面的非法操作或错误」</strong>，是 Spring 注解体系中配置错误的「标准化异常类型」</p>
<p>（3）<strong>IntrospectionFailureLogger</strong></p>
<p><strong>控制当注解内省（Introspection）失败时，应该以何种方式记录或处理这个失败。</strong> 它并不参与正常的注解扫描、合并或解析流程，而是在<strong>反射读取注解元数据出现意外</strong>时，决定是记录日志、完全静默还是直接抛出异常。</p>
<table>
<thead>
<tr>
<th align="left">枚举值</th>
<th align="left">行为</th>
<th align="left">设计目的与适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><code>DEBUG</code></strong></td>
<td align="left">仅在 <strong>DEBUG</strong> 日志级别记录失败信息。</td>
<td align="left"><strong>开发和调试阶段</strong>。开发者需要看到所有可能的线索，但又不希望警告干扰。</td>
</tr>
<tr>
<td align="left"><strong><code>INFO</code></strong></td>
<td align="left">在 <strong>INFO</strong> 日志级别记录失败信息。</td>
<td align="left"><strong>生产环境监控</strong>。希望知晓有非关键性故障发生，但不中断程序。</td>
</tr>
</tbody></table>
<p>Java 内省是通过反射解析 Bean 类的属性、方法、注解等元信息的过程（如 <code>java.beans.BeanInfo</code>、<code>java.beans.Introspector</code>），也是 Spring 实现 BeanWrapper、注解解析、属性注入的基础。内省过程中可能因反射权限、方法 &#x2F; 字段不存在、类加载异常等导致失败，而这类失败往往<strong>非致命</strong>（比如某个非核心属性访问失败，不影响 Bean 核心功能），因此无需抛出异常，只需低级别日志记录即可</p>
<h5 id="1-6总结"><a href="#1-6总结" class="headerlink" title="1.6总结"></a>1.6总结</h5><p>各部分流程测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xin.valv.spring.core.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.annotation.SynthesizedAnnotation;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.MethodParameter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.Ordered;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.annotation.AliasFor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.type.classreading.MetadataReader;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.type.classreading.MetadataReaderFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.type.classreading.SimpleMetadataReaderFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationTest</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟Spring的<span class="doctag">@Component</span>元注解</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line">    <span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line">    <span class="meta">@Documented</span></span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@interface</span> MyComponent &#123;</span><br><span class="line">        String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用@AliasFor实现属性别名</span></span><br><span class="line">        <span class="meta">@AliasFor(&quot;value&quot;)</span></span><br><span class="line">        String <span class="title function_">name</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟<span class="doctag">@Service</span>，继承自<span class="doctag">@MyComponent</span></span></span><br><span class="line"><span class="comment">     * 展示元注解继承和属性覆盖</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line">    <span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line">    <span class="meta">@Documented</span></span><br><span class="line">    <span class="meta">@MyComponent</span>  <span class="comment">// 元注解关系</span></span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@interface</span> MyService &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 继承并覆盖MyComponent的value属性</span></span><br><span class="line">        <span class="meta">@AliasFor(annotation = MyComponent.class, attribute = &quot;value&quot;)</span></span><br><span class="line">        String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@AliasFor(annotation = MyComponent.class, attribute = &quot;name&quot;)</span></span><br><span class="line">        String <span class="title function_">serviceName</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自己的属性</span></span><br><span class="line">        String <span class="title function_">version</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;1.0&quot;</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="title function_">transactional</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟<span class="doctag">@Repository</span>，展示<span class="doctag">@Order</span>组合使用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line">    <span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line">    <span class="meta">@Documented</span></span><br><span class="line">    <span class="meta">@MyComponent</span></span><br><span class="line">    <span class="meta">@Order</span>  <span class="comment">// 可以定义顺序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@interface</span> MyRepository &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@AliasFor(annotation = MyComponent.class, attribute = &quot;value&quot;)</span></span><br><span class="line">        String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 异常转换标记</span></span><br><span class="line">        <span class="type">boolean</span> <span class="title function_">exceptionTranslation</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户服务 - 使用<span class="doctag">@Service</span>注解</span></span><br><span class="line"><span class="comment">     * value=&quot;userService&quot;将通过<span class="doctag">@AliasFor</span>传递到<span class="doctag">@MyComponent</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@MyService(value = &quot;userService&quot;, version = &quot;2.0&quot;)</span></span><br><span class="line">    <span class="meta">@Order(Ordered.HIGHEST_PRECEDENCE + 1)</span>  <span class="comment">// 高优先级</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;UserService processing...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户仓库 - 使用<span class="doctag">@Repository</span>注解</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@MyRepository(value = &quot;userRepository&quot;)</span></span><br><span class="line">    <span class="meta">@Order(Ordered.HIGHEST_PRECEDENCE + 2)</span>  <span class="comment">// 比UserService优先级低</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserRepository</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;UserRepository saving...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订单服务 - 展示默认值的使用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@MyService(serviceName = &quot;orderService&quot;)</span>  <span class="comment">// 只设置serviceName，value将使用默认值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createOrder</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;OrderService creating order...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟的类路径扫描器</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Class&lt;?&gt;&gt; scannedClasses = Arrays.asList(</span><br><span class="line">            UserService.class,</span><br><span class="line">            UserRepository.class,</span><br><span class="line">            OrderService.class</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阶段1: 模拟类路径扫描与注解发现</span></span><br><span class="line"><span class="comment">     * 对应: ClassPathScanningCandidateComponentProvider</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">phase1_scanAndDiscover</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;阶段1: 类路径扫描与注解发现&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;模拟ClassPathBeanDefinitionScanner工作:&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; clazz : scannedClasses) &#123;</span><br><span class="line">            <span class="comment">// 使用AnnotationUtils判断是否是需要处理的组件</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isComponent</span> <span class="operator">=</span> AnnotatedElementUtils.isAnnotated(</span><br><span class="line">                    clazz, MyComponent.class);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isComponent) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;  ✓ 发现组件: &quot;</span> + clazz.getSimpleName());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 收集所有直接声明的注解</span></span><br><span class="line">                Annotation[] anns = AnnotationUtils.getAnnotations(clazz);</span><br><span class="line">                System.out.println(<span class="string">&quot;    直接注解: &quot;</span> +</span><br><span class="line">                        Arrays.stream(anns)</span><br><span class="line">                                .map(a -&gt; a.annotationType().getSimpleName())</span><br><span class="line">                                .toArray()</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阶段2: 注解元数据解析</span></span><br><span class="line"><span class="comment">     * 对应: AnnotationMetadata, MergedAnnotations</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">phase2_parseMetadata</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;阶段2: 注解元数据解析&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;使用MergedAnnotations进行深度解析:&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; clazz : scannedClasses) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;\n► 解析类: &quot;</span> + clazz.getSimpleName());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建MergedAnnotations（Spring内部通过MergedAnnotations.from()）</span></span><br><span class="line">            <span class="type">MergedAnnotations</span> <span class="variable">mergedAnnotations</span> <span class="operator">=</span></span><br><span class="line">                    MergedAnnotations.from(clazz,</span><br><span class="line">                            MergedAnnotations.SearchStrategy.TYPE_HIERARCHY);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2.1 检查是否存在特定注解（考虑元注解）</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">hasService</span> <span class="operator">=</span> mergedAnnotations.isPresent(MyService.class);</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">hasComponent</span> <span class="operator">=</span> mergedAnnotations.isPresent(MyComponent.class);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;  - 拥有MyService注解: &quot;</span> + hasService);</span><br><span class="line">            System.out.println(<span class="string">&quot;  - 拥有MyComponent注解(含元注解): &quot;</span> + hasComponent);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2.2 获取特定注解的合并版本</span></span><br><span class="line">            <span class="keyword">if</span> (hasService) &#123;</span><br><span class="line">                MergedAnnotation&lt;MyService&gt; serviceAnn =</span><br><span class="line">                        mergedAnnotations.get(MyService.class);</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;  - MyService属性:&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;    * value: &quot;</span> + serviceAnn.getString(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">                System.out.println(<span class="string">&quot;    * serviceName: &quot;</span> + serviceAnn.getString(<span class="string">&quot;serviceName&quot;</span>));</span><br><span class="line">                System.out.println(<span class="string">&quot;    * version: &quot;</span> + serviceAnn.getString(<span class="string">&quot;version&quot;</span>));</span><br><span class="line">                System.out.println(<span class="string">&quot;    * transactional: &quot;</span> + serviceAnn.getBoolean(<span class="string">&quot;transactional&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2.3 获取@Order信息</span></span><br><span class="line">            MergedAnnotation&lt;Order&gt; orderAnn = mergedAnnotations.get(Order.class);</span><br><span class="line">            <span class="keyword">if</span> (orderAnn.isPresent()) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">orderValue</span> <span class="operator">=</span> orderAnn.getInt(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;  - @Order值: &quot;</span> + orderValue +</span><br><span class="line">                        <span class="string">&quot; (优先级: &quot;</span> + getPriorityText(orderValue) + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阶段3: 注解属性合并与合成</span></span><br><span class="line"><span class="comment">     * 对应: SynthesizedAnnotation, <span class="doctag">@AliasFor</span>处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">phase3_mergeAndSynthesize</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;阶段3: 注解属性合并与@AliasFor处理&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; targetClass = UserService.class;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.1 获取合并后的注解</span></span><br><span class="line">        <span class="type">MyService</span> <span class="variable">serviceAnn</span> <span class="operator">=</span> AnnotatedElementUtils.getMergedAnnotation(</span><br><span class="line">                targetClass, MyService.class);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;► 合成注解测试 - &quot;</span> + targetClass.getSimpleName());</span><br><span class="line">        System.out.println(<span class="string">&quot;  合成注解类型: &quot;</span> + serviceAnn.getClass().getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;  是否是JDK动态代理: &quot;</span> +</span><br><span class="line">                serviceAnn.getClass().getName().contains(<span class="string">&quot;$Proxy&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.2 验证@AliasFor效果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\n► @AliasFor属性映射验证:&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取MyComponent的合并注解（通过元注解关系）</span></span><br><span class="line">        <span class="type">MyComponent</span> <span class="variable">componentAnn</span> <span class="operator">=</span> AnnotatedElementUtils.getMergedAnnotation(</span><br><span class="line">                targetClass, MyComponent.class);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;  MyService.value(): \&quot;&quot;</span> + serviceAnn.value() + <span class="string">&quot;\&quot;&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;  MyComponent.value(): \&quot;&quot;</span> + componentAnn.value() + <span class="string">&quot;\&quot;&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;  ✓ 验证: MyService.value() == MyComponent.value()? &quot;</span> +</span><br><span class="line">                serviceAnn.value().equals(componentAnn.value()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.3 反射查看合成注解的属性源</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\n► 反射查看注解方法:&quot;</span>);</span><br><span class="line">        Method[] methods = serviceAnn.annotationType().getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> method.invoke(serviceAnn);</span><br><span class="line">            System.out.println(<span class="string">&quot;  &quot;</span> + method.getName() + <span class="string">&quot;() = &quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阶段4: 应用解析结果 - Bean排序</span></span><br><span class="line"><span class="comment">     * 对应: AnnotationAwareOrderComparator</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">phase4_applySorting</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;阶段4: 应用解析结果 - Bean排序&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.1 创建Bean实例列表（模拟Spring容器中的Bean）</span></span><br><span class="line">        List&lt;Object&gt; beans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        beans.add(<span class="keyword">new</span> <span class="title class_">UserRepository</span>());  <span class="comment">// Order = HIGHEST+2</span></span><br><span class="line">        beans.add(<span class="keyword">new</span> <span class="title class_">OrderService</span>());    <span class="comment">// 无@Order，默认最低</span></span><br><span class="line">        beans.add(<span class="keyword">new</span> <span class="title class_">UserService</span>());     <span class="comment">// Order = HIGHEST+1</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;排序前Bean顺序:&quot;</span>);</span><br><span class="line">        beans.forEach(b -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">orderInfo</span> <span class="operator">=</span> getBeanOrderInfo(b);</span><br><span class="line">            System.out.println(<span class="string">&quot;  &quot;</span> + b.getClass().getSimpleName() + orderInfo);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.2 使用AnnotationAwareOrderComparator排序</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\n使用AnnotationAwareOrderComparator排序...&quot;</span>);</span><br><span class="line">        AnnotationAwareOrderComparator.sort(beans);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n排序后Bean顺序 (数值小的优先):&quot;</span>);</span><br><span class="line">        beans.forEach(b -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">orderInfo</span> <span class="operator">=</span> getBeanOrderInfo(b);</span><br><span class="line">            System.out.println(<span class="string">&quot;  &quot;</span> + b.getClass().getSimpleName() + orderInfo);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.3 单独比较两个Bean</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\nBean优先级比较:&quot;</span>);</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserService</span>();</span><br><span class="line">        <span class="type">UserRepository</span> <span class="variable">userRepo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserRepository</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">comparison</span> <span class="operator">=</span> AnnotationAwareOrderComparator.INSTANCE</span><br><span class="line">                .compare(userService, userRepo);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;  UserService vs UserRepository = &quot;</span> + comparison);</span><br><span class="line">        System.out.println(<span class="string">&quot;  &quot;</span> + (comparison &lt; <span class="number">0</span> ? <span class="string">&quot;UserService优先级更高&quot;</span> :</span><br><span class="line">                comparison &gt; <span class="number">0</span> ? <span class="string">&quot;UserRepository优先级更高&quot;</span> : <span class="string">&quot;优先级相同&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== 工具方法 ==========</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getPriorityText</span><span class="params">(<span class="type">int</span> orderValue)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (orderValue &lt;= Ordered.HIGHEST_PRECEDENCE) <span class="keyword">return</span> <span class="string">&quot;最高&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (orderValue &gt;= Ordered.LOWEST_PRECEDENCE) <span class="keyword">return</span> <span class="string">&quot;最低&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (orderValue == Ordered.LOWEST_PRECEDENCE - <span class="number">100</span>) <span class="keyword">return</span> <span class="string">&quot;默认&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;普通&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getBeanOrderInfo</span><span class="params">(Object bean)</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">order</span> <span class="operator">=</span> OrderUtils.getOrder(bean.getClass());</span><br><span class="line">        <span class="keyword">if</span> (order == <span class="literal">null</span>) &#123;</span><br><span class="line">            order = Ordered.LOWEST_PRECEDENCE; <span class="comment">// 默认最低</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot; [order=&quot;</span> + order + <span class="string">&quot;, 优先级=&quot;</span> + getPriorityText(order) + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试注解的解析流程</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAnnotationProcess</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;========== Spring注解解析完整流程 ==========\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 阶段1: 类路径扫描与注解发现</span></span><br><span class="line">        phase1_scanAndDiscover();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n----------\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 阶段2: 注解元数据解析</span></span><br><span class="line">        phase2_parseMetadata();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n----------\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 阶段3: 注解属性合并与合成</span></span><br><span class="line">        phase3_mergeAndSynthesize();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n----------\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 阶段4: 应用解析结果（排序）</span></span><br><span class="line">        phase4_applySorting();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上代码仅作测试，实际的Spring框架中的解析流程为：</p>
<ol>
<li>类扫描（ASM 读取字节码，轻量筛选）<br>Spring 启动时，<code>@ComponentScan</code> 会触发包扫描，此时为了避免加载所有类到 JVM（性能损耗），Spring 会用 <strong>ASM 框架</strong> 直接读取<code>.class</code>文件的字节码（不加载类），然后：<br>（1）检查类是否包含目标注解（如<code>@Component</code>、<code>@Service</code>）<br>（2）提取注解的基础元数据（如注解类型），筛选出「候选 Bean 类」</li>
<li>深度解析（反射解析 Class 对象，核心逻辑）<br>对 ASM 筛选出的候选类，Spring 会通过<code>Class.forName()</code>加载类到 JVM，生成<code>Class</code>对象，然后通过 <strong>JDK 反射 API</strong> 解析注解：<br>（1）解析类级注解：<code>Class.getAnnotations()</code>、<code>Class.getAnnotation(Component.class)</code><br>（2）解析字段级注解：<code>Field.getAnnotations()</code>（如<code>@Autowired</code>、<code>@Value</code>）<br>（3）解析方法级注解：<code>Method.getAnnotations()</code>（如<code>@RequestMapping</code>、<code>@PostConstruct</code>）<br>（4）提取注解属性：如<code>@RequestMapping(value = &quot;/user&quot;)</code>中的<code>value</code>值、<code>@Autowired(required = false)</code>中的<code>required</code>值<br>（5）处理注解的特殊逻辑：如合成注解（<code>@RestController = @Controller + @ResponseBody</code>）、注解继承（<code>@Inherited</code>）等（Spring 封装了<code>AnnotationUtils</code>、<code>AnnotatedElementUtils</code>工具类增强反射能力）</li>
<li>注解生效（Bean 生命周期处理）<br>解析完注解后，Spring 会将注解信息封装到<code>BeanDefinition</code>中，在 Bean 的实例化、属性填充、初始化阶段触发注解逻辑<br>（1）如<code>@Autowired</code>触发依赖注入<br>（2）<code>@Value</code>触发属性值解析<br>（3）<code>@PostConstruct</code>触发初始化方法执行</li>
</ol>
<table>
<thead>
<tr>
<th>阶段</th>
<th>工具 &#x2F; 方式</th>
<th>核心目的</th>
<th>是否直接解析字节码</th>
</tr>
</thead>
<tbody><tr>
<td>类扫描</td>
<td>ASM</td>
<td>轻量筛选候选 Bean 类</td>
<td>是（仅读取元数据）</td>
</tr>
<tr>
<td>深度解析</td>
<td>JDK 反射（封装）</td>
<td>解析注解属性 + 核心逻辑</td>
<td>否（解析 Class 对象）</td>
</tr>
<tr>
<td>注解生效</td>
<td>Bean 生命周期</td>
<td>触发注解对应的业务逻辑</td>
<td>否</td>
</tr>
</tbody></table>
<h4 id="2-type-包："><a href="#2-type-包：" class="headerlink" title="2.type 包："></a>2.type 包：</h4><h1 id="持续更新当中…"><a href="#持续更新当中…" class="headerlink" title="持续更新当中…."></a>持续更新当中….</h1></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.wxin.icu">xin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.wxin.icu/2025/11/16/Spring-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">https://blog.wxin.icu/2025/11/16/Spring-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.wxin.icu" target="_blank">xin 的 博客</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/default/2.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width no-desc" href="/2025/11/09/JVM%20%E5%AD%A6%E4%B9%A0%E5%A4%A7%E7%BA%B2%EF%BC%88%E7%B3%BB%E7%BB%9F%E7%89%88%EF%BC%89/" title="JVM 学习大纲（简易版）"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/default/5.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">JVM 学习大纲（简易版）</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">xin</div><div class="author-info-description">收藏从未停止，学习从未开始!</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xin-github-test"><i class="fab fa-github"></i><span>关注我的github</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/xin-github-test" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:1246814044@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客！！！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#title-Spring-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BBdate-2025-11-16-09-55-01tags-java-Spring-encryptcategory-note"><span class="toc-number">1.</span> <span class="toc-text">title: Spring 源码解读date: 2025-11-16 09:55:01tags:  - java  - Spring  - encryptcategory: note</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring-5-3-8"><span class="toc-number"></span> <span class="toc-text">Spring-5.3.8</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6%E5%9B%BE"><span class="toc-number"></span> <span class="toc-text">整体框架图</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-Spring-Core"><span class="toc-number"></span> <span class="toc-text">1.Spring-Core</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1asm%E5%8C%85%EF%BC%9A%E5%AD%97%E8%8A%82%E7%A0%81%E6%93%8D%E4%BD%9C%E6%A1%86%E6%9E%B6"><span class="toc-number">1.</span> <span class="toc-text">1.1asm包：字节码操作框架</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%881%EF%BC%89Visitor%EF%BC%88%E8%AE%BF%E9%97%AE%E5%99%A8%EF%BC%89%E5%92%8C-Writer%EF%BC%88%E7%BB%84%E8%A3%85%E5%99%A8%EF%BC%89"><span class="toc-number">1.1.</span> <span class="toc-text">（1）Visitor（访问器）和 Writer（组装器）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%882%EF%BC%89Attribute%E7%B1%BB"><span class="toc-number">1.2.</span> <span class="toc-text">（2）Attribute类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E5%85%B6%E4%BB%96%E7%B1%BB%EF%BC%88%E8%BE%85%E7%BB%84%E7%B1%BB%EF%BC%89"><span class="toc-number">1.3.</span> <span class="toc-text">（3）其他类（辅组类）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2core%E5%8C%85%EF%BC%9A%E6%A0%B8%E5%BF%83%E5%B7%A5%E5%85%B7%E5%92%8C%E5%9F%BA%E7%A1%80%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.</span> <span class="toc-text">1.2core包：核心工具和基础接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E7%B1%BB%E5%9E%8B%E4%B8%8E%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%B1%82"><span class="toc-number">2.1.</span> <span class="toc-text">（1）类型与注解处理层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-annotation%E5%8C%85%EF%BC%9A%E5%8F%91%E7%8E%B0%E5%92%8C%E5%A4%84%E7%90%86%E6%B3%A8%E8%A7%A3%E4%BF%A1%E6%81%AF"><span class="toc-number">2.1.1.</span> <span class="toc-text">1.annotation包：发现和处理注解信息</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1%E6%A0%B8%E5%BF%83%E5%85%83%E6%95%B0%E6%8D%AE%E7%B1%BB"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">1.1核心元数据类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2%E6%89%AB%E6%8F%8F%E4%B8%8E%E5%85%83%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86"><span class="toc-number">2.1.1.2.</span> <span class="toc-text">1.2扫描与元数据采集</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-3%E6%B3%A8%E8%A7%A3%E5%B1%9E%E6%80%A7%E5%A4%84%E7%90%86%E4%BB%A5%E5%8F%8A%E5%90%88%E5%B9%B6"><span class="toc-number">2.1.1.3.</span> <span class="toc-text">1.3注解属性处理以及合并</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-4%E6%B3%A8%E8%A7%A3%E8%BF%87%E6%BB%A4%E5%99%A8%E4%B8%8E%E9%80%89%E6%8B%A9%E5%99%A8%E7%B1%BB"><span class="toc-number">2.1.1.4.</span> <span class="toc-text">1.4注解过滤器与选择器类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-5%E7%89%B9%E6%AE%8A%E7%94%A8%E9%80%94%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">2.1.1.5.</span> <span class="toc-text">1.5特殊用途工具类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-6%E6%80%BB%E7%BB%93"><span class="toc-number">2.1.1.6.</span> <span class="toc-text">1.6总结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-type-%E5%8C%85%EF%BC%9A"><span class="toc-number">2.1.2.</span> <span class="toc-text">2.type 包：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E5%BD%93%E4%B8%AD%E2%80%A6"><span class="toc-number"></span> <span class="toc-text">持续更新当中….</span></a></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/11/16/Spring-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/" title="无标题"><img src="/img/loading.gif" data-lazy-src="/img/default/2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无标题"/></a><div class="content"><a class="title" href="/2025/11/16/Spring-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/" title="无标题">无标题</a><time datetime="2025-11-16T11:31:26.255Z" title="发表于 2025-11-16 19:31:26">2025-11-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/11/09/JVM%20%E5%AD%A6%E4%B9%A0%E5%A4%A7%E7%BA%B2%EF%BC%88%E7%B3%BB%E7%BB%9F%E7%89%88%EF%BC%89/" title="JVM 学习大纲（简易版）"><img src="/img/loading.gif" data-lazy-src="/img/default/5.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JVM 学习大纲（简易版）"/></a><div class="content"><a class="title" href="/2025/11/09/JVM%20%E5%AD%A6%E4%B9%A0%E5%A4%A7%E7%BA%B2%EF%BC%88%E7%B3%BB%E7%BB%9F%E7%89%88%EF%BC%89/" title="JVM 学习大纲（简易版）">JVM 学习大纲（简易版）</a><time datetime="2025-11-09T01:56:59.000Z" title="发表于 2025-11-09 09:56:59">2025-11-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/11/04/AI-Nano%20Banana%E6%8F%90%E7%A4%BA%E8%AF%8D%E5%A4%A7%E5%85%A8/" title="AI-Nano Banana提示词大全"><img src="/img/loading.gif" data-lazy-src="/img/default/3.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="AI-Nano Banana提示词大全"/></a><div class="content"><a class="title" href="/2025/11/04/AI-Nano%20Banana%E6%8F%90%E7%A4%BA%E8%AF%8D%E5%A4%A7%E5%85%A8/" title="AI-Nano Banana提示词大全">AI-Nano Banana提示词大全</a><time datetime="2025-11-04T06:09:03.000Z" title="发表于 2025-11-04 14:09:03">2025-11-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/11/03/%E6%96%B0%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B%EF%BC%88Vue3+SpringBoot2%EF%BC%89/" title="新项目开发流程"><img src="/img/loading.gif" data-lazy-src="/img/default/8.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="新项目开发流程"/></a><div class="content"><a class="title" href="/2025/11/03/%E6%96%B0%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B%EF%BC%88Vue3+SpringBoot2%EF%BC%89/" title="新项目开发流程">新项目开发流程</a><time datetime="2025-11-03T01:46:19.707Z" title="发表于 2025-11-03 09:46:19">2025-11-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/11/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91-%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AE/" title="科学上网-各种协议"><img src="/img/loading.gif" data-lazy-src="/img/default/10.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="科学上网-各种协议"/></a><div class="content"><a class="title" href="/2025/01/11/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91-%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AE/" title="科学上网-各种协议">科学上网-各种协议</a><time datetime="2025-01-11T08:09:03.000Z" title="发表于 2025-01-11 16:09:03">2025-01-11</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/default/2.png);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By xin</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.1</a></span></div><div class="footer_custom_text">Hi, 欢迎来到我的 <a href="https://blog.wxin.icu/">blog</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.jsdelivr.net/npm/hexo-theme-butterfly@5.5.1/source/js/utils.min.js"></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-butterfly@5.5.1/source/js/main.min.js"></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-butterfly@5.5.1/source/js/tw_cn.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"></div><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/click-show-text.min.js" data-mobile="false" data-text="基,尼,太,美" data-fontsize="15px" data-random="false" async="async"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      const usePjax = true
      false
        ? (usePjax ? pjax.loadUrl('/404.html') : window.location.href = '/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索..." type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/hexo-theme-butterfly@5.5.1/source/js/search/local-search.min.js"></script></div></div></body></html>