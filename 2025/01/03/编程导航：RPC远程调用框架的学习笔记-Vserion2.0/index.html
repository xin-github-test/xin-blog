<!DOCTYPE html><html lang="en" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Hexo</title><link rel="icon" type="image/x-icon" href="/favicon.ico"><link rel="preload" as="font" crossorigin="anonymous" href="/font/Bender.ttf"><link rel="preload" as="font" crossorigin="anonymous" href="/font/BenderLight.ttf"><link rel="preload" as="font" crossorigin="anonymous" href="/font/JetBrainsMono-Regular.woff2"><link rel="stylesheet" href="/css/arknights.css"><style>@font-face {
  font-family: Bender;
  src: local('Bender'), url("/font/Bender.ttf"), url("/font/Bender.otf");
}
@font-face {
  font-family: BenderLight;
  src: local('BenderLight'), url("/font/BenderLight.ttf");
}
@font-face {
  font-family: 'JetBrains Mono';
  src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}
</style><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"Enter here","blurHolder":"Search","noResult":"Data \"$0\" not found"},"code":{"codeInfo":"$0 - $1 lines","copy":"copy"}}</script><link type="text/css" rel="stylesheet" href="/lib/encrypt/hbe.style.css"><script src="//unpkg.com/mermaid@10.5.0/dist/mermaid.min.js"></script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/css/all.min.css"><script>if (window.localStorage.getItem('theme-mode') === 'light')
 document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark')
 document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.woff2") format('woff2');
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
 --dark-background: url('https://ak.hypergryph.com/assets/index/images/ak/pc/bk.jpg');
 --light-background: url('/img/bk.jpg');
 --theme-encrypt-confirm: 'confirm'
}</style><script defer src="/js/arknights.js"></script><script defer src="/js/search.js"></script><script defer type="module">import mermaid from '//unpkg.com/mermaid@10.5.0/dist/mermaid.esm.mjs';
window.mermaid = mermaid;
code.paintMermaid();
</script><script async src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script async src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script async src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script async src="/lib/encrypt/hbe.js"></script><script async src="/js/pjax.js"></script><script class="pjax-js">reset= () => {document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js','data-pjax','.busuanzi'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script><script class="pjax-js">reset= () => {document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><nav><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Search" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup" tabindex="0"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1></h1></div><hr><div id="post-content"><h1 id="编程导航：RPC远程调用框架的学习笔记-Vserion2-0"><a href="#编程导航：RPC远程调用框架的学习笔记-Vserion2-0" class="headerlink" title="编程导航：RPC远程调用框架的学习笔记-Vserion2.0"></a>编程导航：RPC远程调用框架的学习笔记-Vserion2.0</h1><h1 id="一、全局配置加载"><a href="#一、全局配置加载" class="headerlink" title="一、全局配置加载"></a>一、全局配置加载</h1><h2 id="1-需求分析"><a href="#1-需求分析" class="headerlink" title="1.需求分析"></a>1.需求分析</h2><p>在上一个版本中，很多配置都是硬编码的，不利于扩展，比如一些配置信息：注册中心的地址，序列化方式，网络服务端口号等；</p>
<p>因此这个版本中需要一套**<code>全局配置加载功能</code>**，能让RPC框架轻松地从配置文件中读取配置，并且维护一个全局的配置对象，便于框架快速获取到一致的配置</p>
<h2 id="2-设计方案"><a href="#2-设计方案" class="headerlink" title="2.设计方案"></a>2.设计方案</h2><h3 id="配置项"><a href="#配置项" class="headerlink" title="配置项"></a>配置项</h3><p>首先先配置几个简单的配置项：</p>
<ul>
<li>name：版本名称</li>
<li>version：版本号</li>
<li>serverHost：服务器主机名</li>
<li>serverPort：服务器端口</li>
</ul>
<p>后续随着框架功能的扩展，会不断地增加配置项，还可以适当地对配置项进行分组，以下是一些常见的RPC框架的配置项：</p>
<ul>
<li>注册中心地址：服务提供者和服务消费者都需要指定注册中心的地址，以便进行服务注册和发现</li>
<li>服务接口：服务提供者需要指定提供的服务接口，而服务消费者需要指定要调用的服务接口</li>
<li>序列化方式：服务提供者和服务消费者都需要指定序列化方式，以便在网络传输数据时进行序列化和反序列化</li>
<li>网络通信协议：服务提供者和服务消费者都需要选择合适的网络通信协议，比如TCP、HTTP等 </li>
<li>超时设置：服务提供者和服务消费者都需要设置超时时间，以便在调用服务时进行超时处理</li>
<li>负载均衡策略：服务消费者需要指定负载均衡策略，以决定调用哪个服务提供者实例</li>
<li>服务端线程模型：服务提供者需要指定服务端线程模型，以决定如何处理客户端请求</li>
</ul>
<h3 id="配置文件的读取"><a href="#配置文件的读取" class="headerlink" title="配置文件的读取"></a>配置文件的读取</h3><p>可以使用JAVA的Properties类自行编写，也可以使用第三方工具，比如Hutool的settting模块，可以直接读取指定名称的配置文件的部分配置信息，并且转换成java对象</p>
<p>参考文档：<a target="_blank" rel="noopener" href="https://doc.hutool.cn/pages/Props/">Hutools使用文档说明</a></p>
<p>一般情况下，读取配置application.properties，并通过文件名后缀方式来区分多环境：application-prod.properties、application-test.properties</p>
<h2 id="3-开发实现"><a href="#3-开发实现" class="headerlink" title="3.开发实现"></a>3.开发实现</h2><h2 id="项目实现"><a href="#项目实现" class="headerlink" title="项目实现"></a>项目实现</h2><p>。。。。。</p>
<h2 id="配置加载"><a href="#配置加载" class="headerlink" title="配置加载"></a>配置加载</h2><p>。。。。。</p>
<h2 id="维护全局配置对象"><a href="#维护全局配置对象" class="headerlink" title="维护全局配置对象"></a>维护全局配置对象</h2><p>RPC框架中需要维护一个全局的配置对象，在引入RPC框架的项目启动时，从配置文件中读取配置并创建实例对象，之后就可以集中地从这个对象中获取配置信息，而不用每次加载配置时再重新读取配置，减少性能的开销。</p>
<p>使用设计模式中的<code>单例模式</code>，就能够很轻松地实现这个需求了。</p>
<p>一般情况下，我们会使用holder来维护全局配置对象实例。在我们的项目中，可以换一个更优雅的命名，使用<code>RpcApplication</code>类作为RPC项目的启动入口，并且维护项目全局用到的变量。</p>
<p>此处还涉及<code>双检锁单例模式的经典实现</code>：支持在获取配置时才调用init方法实现懒加载</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>。。。</p>
<h2 id="扩展思路"><a href="#扩展思路" class="headerlink" title="扩展思路"></a>扩展思路</h2><ol>
<li>支持读取application.yml、application.yaml等不同格式的配置文件</li>
<li>支持监听配置文件的变更，并自动更新配置对象</li>
<li>配置文件支持中文</li>
<li>配置分组。随着后续配置项的增多，可以考虑对配置项进行分组</li>
</ol>
<p>参考思路：</p>
<ul>
<li>前俩个扩展思路：使用Hutool工具的<code>props.autoload()</code>可以实现配置文件变更的监听和自动加载</li>
<li>第三个：需要注意编码问题</li>
<li>最后一个可以通过嵌套配置类实现</li>
</ul>
<h1 id="二、接口Mock"><a href="#二、接口Mock" class="headerlink" title="二、接口Mock"></a>二、接口Mock</h1><h2 id="1-需求分析-1"><a href="#1-需求分析-1" class="headerlink" title="1.需求分析"></a>1.需求分析</h2><h3 id="什么是mock"><a href="#什么是mock" class="headerlink" title="什么是mock?"></a>什么是mock?</h3><p>RPC框架的核心功能是远程调用其他远程服务，但是在实际开发和测试过程中，有时可能无法直接访问真实的远程服务，或者访问真实的远程服务可能会产生不可控的影响，比如：网络延迟、服务不稳定等。在这种情况下，就需要使用mock服务来模拟远程服务的行为，以便进行接口的测试、开发和调试。</p>
<p>mock是指模拟对象，通常用于测试代码中，特别是在单元测试中，便于跑通业务流程。</p>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> &#123;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        doSomething();<br>        orderService.order();<br>        doSomething();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果订单服务还没上线，那么这个流程就跑不通</p>
<p>但是如果给orderService设置一个模拟对象，调用它的order方法时，随便返回一个值，就能执行后续代码，这就是mock的作用</p>
<h3 id="为什么要支持mock"><a href="#为什么要支持mock" class="headerlink" title="为什么要支持mock"></a>为什么要支持mock</h3><p>虽然mock服务不是RPC框架的核心能力，但是它的开发成本并不高，而且加上这个功能之后，开发者可以轻松调用服务接口，跑通业务流程，不必依赖真实的远程服务，提高用户体验</p>
<h2 id="2-设计方案-1"><a href="#2-设计方案-1" class="headerlink" title="2.设计方案"></a>2.设计方案</h2><h3 id="如何创建模拟对象？"><a href="#如何创建模拟对象？" class="headerlink" title="如何创建模拟对象？"></a>如何创建模拟对象？</h3><p>前面提到了一种动态创建对象的方法——动态代理。之前通过动态代理创建远程调用对象。同理，<code>通过动态代理创建一个调用方法时返回固定值的对象</code></p>
<h3 id="开发实现"><a href="#开发实现" class="headerlink" title="开发实现"></a>开发实现</h3><ul>
<li>为了便于管理，可以支持开发者通过修改配置文件的方式开启mock，因此首先给全局配置类<code>RpcConfig</code>新增mock字段，默认值为false</li>
</ul>
<h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><p>。。。。。。</p>
<h3 id="扩展思路-1"><a href="#扩展思路-1" class="headerlink" title="扩展思路"></a>扩展思路</h3><ol>
<li>完善Mock的逻辑，支持返回更多类型的默认值</li>
</ol>
<p>参考思路：使用Faker之类的伪造数据生成库，来生成默认值</p>
<h1 id="三、序列化器和SPI机制"><a href="#三、序列化器和SPI机制" class="headerlink" title="三、序列化器和SPI机制"></a>三、序列化器和SPI机制</h1><h2 id="1-需求分析-2"><a href="#1-需求分析-2" class="headerlink" title="1.需求分析"></a>1.需求分析</h2><p>无论是请求还是响应，都会涉及参数的传输。而java对象是存活在JVM虚拟机中的，如果想在其它位置存储并访问，或者在网络上进行传输，就需要进行序列化和饭序列化。</p>
<p>之前已经实现了基于java原生序列化的序列器，但是对于一个完善的RPC框架，还需要思考以下几个问题：</p>
<ol>
<li>有没有更好的序列化器实现方式</li>
<li>如何让使用框架的开发者指定使用的序列化器</li>
<li>如何让使用框架的开发者自己定制序列化器</li>
</ol>
<h2 id="2-设计方案-2"><a href="#2-设计方案-2" class="headerlink" title="2.设计方案"></a>2.设计方案</h2><ul>
<li>序列化器实现方式</li>
</ul>
<p>“更好的”序列器，可以是具有更高的性能，或者更小的序列化结果，这样就能更快地完成RPC请求和响应</p>
<p>市面上还有很多主流的序列化方式：JSON、Hessian、Kryo、protobuf等</p>
<ul>
<li>动态使用序列化器</li>
</ul>
<p>理想情况下，应该可以通过配置文件来指定使用的序列化器，在使用序列化器时，根据配置来获取不同的序列化器实例即可</p>
<p>实现：定义一个<code>序列化名称=&gt;序列化器实现类对象</code>的Map，然后根据名称从Map中获取对象即可</p>
<ul>
<li>自定义序列化器</li>
</ul>
<p>如果开发者不想使用我们框架内置的序列化器，想要自己定义一个新的序列化器实现，但不能修改我们写好的代码？</p>
<p>思路：只要我们的框架能够读取到用户自定义的类路径，然后加载这个类，作为Serializer序列化器接口的实现即可，但是这个想法如何实现？</p>
<p>这就需要学习一个新的概念，也是java中一个重要的特性——<code>SPI机制</code></p>
<p>什么是SPI？</p>
<p>SPI（Service Provider Interface）服务提供接口是java的 机制，主要用于实现模块化开发和插件开发</p>
<p>SPI机制允许服务提供者通过特定的配置文件将自己的实现注册到系统中，然后通过反射机制动态加载这些类，而不需要修改原始框架的代码，从而实现了系统的解耦，提高了可扩展性</p>
<p>一个典型的SPI应用场景是JDBC(数据库连接系统)，不同的数据库驱动程序开发者可以使用JDBC库，然后定制自己的数据库驱动程序。</p>
<p>此外，我们使用的主流java开发框架中，几乎都使用到了SPI机制，比如Servlet容器，日志框架，ORM框架，Spring框架。<code>所以这是Java开发者必须掌握的一个重要特性！</code></p>
<p>如何实现SPI?</p>
<p>分为系统实现和自定义实现</p>
<ul>
<li>系统实现</li>
</ul>
<p>其实java内已经提供了SPI机制相关的API接口，可以直接使用，这种方式最简单</p>
<p>1）首先在<code>resources</code>资源目录下创建<code>META-INF/services</code>目录，并且创建一个名称为要实现的接口的空文件</p>
<p class='item-img' data-src='C:\Users\新\AppData\Roaming\Typora\typora-user-images\image-20241006154237907.png'><img src="C:\Users\新\AppData\Roaming\Typora\typora-user-images\image-20241006154237907.png" alt="image-20241006154237907"></p>
<p>2）在文件中填写自己定制的接口实现类的 <code>完整类路径</code>，如图：</p>
<p class='item-img' data-src='C:\Users\新\AppData\Roaming\Typora\typora-user-images\image-20241006154533213.png'><img src="C:\Users\新\AppData\Roaming\Typora\typora-user-images\image-20241006154533213.png" alt="image-20241006154533213"></p>
<p>3）直接使用系统内置的ServiceLoader动态加载指定接口的实现类，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 指定序列化器</span><br><span class="hljs-type">Serializer</span> <span class="hljs-variable">serializer</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>ServiceLoader&lt;Serializer&gt; serviceLoader = ServiceLoader.load(Serializer.class);<br><span class="hljs-keyword">for</span> (Serializer service : serviceLoader) &#123;<br>    serializer = service;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上诉代码能够获取所有文件中编写的实现类对象，选择一个使用即可</p>
<ul>
<li>自定义SPI实现</li>
</ul>
<p>系统实现SPI虽然简单，但是如果我们想定制多个不同的接口实现类，就没办法在框架中指定使用哪一个了，也无法实现我们“通过配置快速指定序列化器”的需求</p>
<p>所以我们需要自己定义SPI机制的实现，只要能够根据配置加载到类即可</p>
<p>比如读取如下的配置文件，能够得到一个<code>序列化器名称=&gt;序列化器实现类对象</code>的映射,之后就可以根据用户配置的序列化器名称动态加载指定实现类对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">jdk=com.yupi.yurpc.serializer.JdkSerializer<br>hessian=com.yupi.yurpc.serializer.HessianSerializer<br>json=com.yupi.yurpc.serializer.JsonSerializer<br>kryo=com.yupi.yurpc.serializer.KryoSerializer<br></code></pre></td></tr></table></figure>

<h2 id="3-开发实现-1"><a href="#3-开发实现-1" class="headerlink" title="3.开发实现"></a>3.开发实现</h2><h3 id="多种序列化器的实现"><a href="#多种序列化器的实现" class="headerlink" title="多种序列化器的实现"></a>多种序列化器的实现</h3><p>分别实现JSON、Kryo和Hessian这三种主流的序列化器</p>
<p>首先引入依赖</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs maven">&lt;!-- 序列化 --&gt;<br>&lt;!-- https://mvnrepository.com/artifact/com.caucho/hessian --&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;com.caucho&lt;/groupId&gt;<br>    &lt;artifactId&gt;hessian&lt;/artifactId&gt;<br>    &lt;version&gt;4.0.66&lt;/version&gt;<br>&lt;/dependency&gt;<br>&lt;!-- https://mvnrepository.com/artifact/com.esotericsoftware/kryo --&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;com.esotericsoftware&lt;/groupId&gt;<br>    &lt;artifactId&gt;kryo&lt;/artifactId&gt;<br>    &lt;version&gt;5.6.0&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure>

<p>然后在序列化器包serializer中分别实现这三种序列化器，此处可以参考网上的代码</p>
<ul>
<li>JSON序列化器</li>
</ul>
<p>json序列化器的实现相对复杂，要考虑一些对象转换的兼容性问题，比如Object数组在序列化后会丢失类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yupi.yurpc.serializer;<br><br><span class="hljs-keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;<br><span class="hljs-keyword">import</span> com.yupi.yurpc.model.RpcRequest;<br><span class="hljs-keyword">import</span> com.yupi.yurpc.model.RpcResponse;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Json 序列化器</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> &lt;a href=&quot;https://github.com/liyupi&quot;&gt;程序员鱼皮&lt;/a&gt;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@learn</span> &lt;a href=&quot;https://codefather.cn&quot;&gt;编程宝典&lt;/a&gt;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@from</span> &lt;a href=&quot;https://yupi.icu&quot;&gt;编程导航知识星球&lt;/a&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JsonSerializer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializer</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">OBJECT_MAPPER</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-type">byte</span>[] serialize(T obj) <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">return</span> OBJECT_MAPPER.writeValueAsBytes(obj);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">deserialize</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] bytes, Class&lt;T&gt; classType)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">T</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> OBJECT_MAPPER.readValue(bytes, classType);<br>        <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> RpcRequest) &#123;<br>            <span class="hljs-keyword">return</span> handleRequest((RpcRequest) obj, classType);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> RpcResponse) &#123;<br>            <span class="hljs-keyword">return</span> handleResponse((RpcResponse) obj, classType);<br>        &#125;<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 由于 Object 的原始对象会被擦除，导致反序列化时会被作为 LinkedHashMap 无法转换成原始对象，因此这里做了特殊处理</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> rpcRequest rpc 请求</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> type       类型</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-doctag">@link</span> T&#125;</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException IO异常</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> &lt;T&gt; T <span class="hljs-title function_">handleRequest</span><span class="hljs-params">(RpcRequest rpcRequest, Class&lt;T&gt; type)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        Class&lt;?&gt;[] parameterTypes = rpcRequest.getParameterTypes();<br>        Object[] args = rpcRequest.getArgs();<br><br>        <span class="hljs-comment">// 循环处理每个参数的类型</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; parameterTypes.length; i++) &#123;<br>            Class&lt;?&gt; clazz = parameterTypes[i];<br>            <span class="hljs-comment">// 如果类型不同，则重新处理一下类型</span><br>            <span class="hljs-keyword">if</span> (!clazz.isAssignableFrom(args[i].getClass())) &#123;<br>                <span class="hljs-type">byte</span>[] argBytes = OBJECT_MAPPER.writeValueAsBytes(args[i]);<br>                args[i] = OBJECT_MAPPER.readValue(argBytes, clazz);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> type.cast(rpcRequest);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 由于 Object 的原始对象会被擦除，导致反序列化时会被作为 LinkedHashMap 无法转换成原始对象，因此这里做了特殊处理</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> rpcResponse rpc 响应</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> type        类型</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-doctag">@link</span> T&#125;</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException IO异常</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> &lt;T&gt; T <span class="hljs-title function_">handleResponse</span><span class="hljs-params">(RpcResponse rpcResponse, Class&lt;T&gt; type)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 处理响应数据</span><br>        <span class="hljs-type">byte</span>[] dataBytes = OBJECT_MAPPER.writeValueAsBytes(rpcResponse.getData());<br>        rpcResponse.setData(OBJECT_MAPPER.readValue(dataBytes, rpcResponse.getDataType()));<br>        <span class="hljs-keyword">return</span> type.cast(rpcResponse);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>Kryo序列化器</li>
</ul>
<p>kryo本身是线程不安全的，所以需要使用ThreadLocal保证每个线程有一个单独的Kryo对象实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yupi.yurpc.serializer;<br><br><span class="hljs-keyword">import</span> com.esotericsoftware.kryo.Kryo;<br><span class="hljs-keyword">import</span> com.esotericsoftware.kryo.io.Input;<br><span class="hljs-keyword">import</span> com.esotericsoftware.kryo.io.Output;<br><br><span class="hljs-keyword">import</span> java.io.ByteArrayInputStream;<br><span class="hljs-keyword">import</span> java.io.ByteArrayOutputStream;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Kryo 序列化器</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> &lt;a href=&quot;https://github.com/liyupi&quot;&gt;程序员鱼皮&lt;/a&gt;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@learn</span> &lt;a href=&quot;https://codefather.cn&quot;&gt;编程宝典&lt;/a&gt;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@from</span> &lt;a href=&quot;https://yupi.icu&quot;&gt;编程导航知识星球&lt;/a&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">KryoSerializer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializer</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * kryo 线程不安全，使用 ThreadLocal 保证每个线程只有一个 Kryo</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;Kryo&gt; KRYO_THREAD_LOCAL = ThreadLocal.withInitial(() -&gt; &#123;<br>        <span class="hljs-type">Kryo</span> <span class="hljs-variable">kryo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Kryo</span>();<br>        <span class="hljs-comment">// 设置动态动态序列化和反序列化类，不提前注册所有类（可能有安全问题）</span><br>        kryo.setRegistrationRequired(<span class="hljs-literal">false</span>);<br>        <span class="hljs-keyword">return</span> kryo;<br>    &#125;);<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-type">byte</span>[] serialize(T obj) &#123;<br>        <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">byteArrayOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>        <span class="hljs-type">Output</span> <span class="hljs-variable">output</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Output</span>(byteArrayOutputStream);<br>        KRYO_THREAD_LOCAL.get().writeObject(output, obj);<br>        output.close();<br>        <span class="hljs-keyword">return</span> byteArrayOutputStream.toByteArray();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">deserialize</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] bytes, Class&lt;T&gt; classType)</span> &#123;<br>        <span class="hljs-type">ByteArrayInputStream</span> <span class="hljs-variable">byteArrayInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(bytes);<br>        <span class="hljs-type">Input</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Input</span>(byteArrayInputStream);<br>        <span class="hljs-type">T</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> KRYO_THREAD_LOCAL.get().readObject(input, classType);<br>        input.close();<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>Hessian序列化器</li>
</ul>
<p>实现比较简单</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yupi.yurpc.serializer;<br><br><span class="hljs-keyword">import</span> com.caucho.hessian.io.HessianInput;<br><span class="hljs-keyword">import</span> com.caucho.hessian.io.HessianOutput;<br><br><span class="hljs-keyword">import</span> java.io.ByteArrayInputStream;<br><span class="hljs-keyword">import</span> java.io.ByteArrayOutputStream;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Hessian 序列化器</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> &lt;a href=&quot;https://github.com/liyupi&quot;&gt;程序员鱼皮&lt;/a&gt;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@learn</span> &lt;a href=&quot;https://codefather.cn&quot;&gt;编程宝典&lt;/a&gt;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@from</span> &lt;a href=&quot;https://yupi.icu&quot;&gt;编程导航知识星球&lt;/a&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HessianSerializer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializer</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-type">byte</span>[] serialize(T object) <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>        <span class="hljs-type">HessianOutput</span> <span class="hljs-variable">ho</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HessianOutput</span>(bos);<br>        ho.writeObject(object);<br>        <span class="hljs-keyword">return</span> bos.toByteArray();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">deserialize</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] bytes, Class&lt;T&gt; tClass)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ByteArrayInputStream</span> <span class="hljs-variable">bis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(bytes);<br>        <span class="hljs-type">HessianInput</span> <span class="hljs-variable">hi</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HessianInput</span>(bis);<br>        <span class="hljs-keyword">return</span> (T) hi.readObject(tClass);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="动态使用序列化器"><a href="#动态使用序列化器" class="headerlink" title="动态使用序列化器"></a>动态使用序列化器</h3><p>。。。</p>
<h3 id="自定义序列化器"><a href="#自定义序列化器" class="headerlink" title="自定义序列化器"></a>自定义序列化器</h3><p>我们使用自定义的SPI机制实现，支持用户自定义序列化器并指定键名</p>
<p>1）指定SPI配置目录</p>
<p>系统内置的SPI机制会加载resources资源目录下的META-INF&#x2F;services目录，那我们自定义的序列化可以去如法炮制，改为读取META-INF&#x2F;rpc目录</p>
<p>我们还可以将SPI配置再分为系统内置SPI和用户自定义SPI，即目录下：</p>
<ul>
<li>用户自定义SPI：<code>META-INF/rpc/custom</code>；用户可以在该目录下新建配置，加载自定义实现类</li>
<li>系统内置SPI：<code>META-INF/rpc/system</code>；RPC框架自带的实现类，比如我们之前开发好的<code>JdkSerializer</code></li>
</ul>
<p>这样一来，所有接口的实现类都可以通过SPI动态加载，不用在代码中硬编码Map来维护实现类了。</p>
<p>直接编写一个系统扩展配置文件，内容为我们之前写好的序列化器</p>
<p>文件名称为：<code>com.xin.rpc.serializer.Serializer</code>，内容为：</p>
<p>2）编写SpiLoader加载器</p>
<p>相当于一个工具类，提供了读取配置并加载实现类的方法</p>
<p>关键实现如下：</p>
<ol>
<li>用Map来存储已加载的配置信息<code>键名=&gt;实现类</code></li>
<li>扫描指定路径，读取每个配置文件，获取到<code>键名=&gt;实现类</code>信息并存储在Map中</li>
<li>定义获取实例的方法，根据用户传入的接口和键名，从Map中找到对应的实现类，然后通过反射获取到实现类对象（可以维护一个对象实例缓存，创建过一次的对象从缓存中读取即可）</li>
</ol>
<p>完整的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yupi.yurpc.spi;<br><br><span class="hljs-keyword">import</span> cn.hutool.core.io.resource.ResourceUtil;<br><span class="hljs-keyword">import</span> com.yupi.yurpc.serializer.Serializer;<br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><br><span class="hljs-keyword">import</span> java.io.BufferedReader;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.InputStreamReader;<br><span class="hljs-keyword">import</span> java.net.URL;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> java.util.concurrent.ConcurrentHashMap;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * SPI 加载器（支持键值对映射）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpiLoader</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 存储已加载的类：接口名 =&gt;（key =&gt; 实现类）</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;String, Map&lt;String, Class&lt;?&gt;&gt;&gt; loaderMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 对象实例缓存（避免重复 new），类路径 =&gt; 对象实例，单例模式</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;String, Object&gt; instanceCache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 系统 SPI 目录</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">RPC_SYSTEM_SPI_DIR</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;META-INF/rpc/system/&quot;</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用户自定义 SPI 目录</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">RPC_CUSTOM_SPI_DIR</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;META-INF/rpc/custom/&quot;</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 扫描路径</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String[] SCAN_DIRS = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;RPC_SYSTEM_SPI_DIR, RPC_CUSTOM_SPI_DIR&#125;;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 动态加载的类列表</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> List&lt;Class&lt;?&gt;&gt; LOAD_CLASS_LIST = Arrays.asList(Serializer.class);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 加载所有类型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loadAll</span><span class="hljs-params">()</span> &#123;<br>        log.info(<span class="hljs-string">&quot;加载所有 SPI&quot;</span>);<br>        <span class="hljs-keyword">for</span> (Class&lt;?&gt; aClass : LOAD_CLASS_LIST) &#123;<br>            load(aClass);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取某个接口的实例</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> tClass</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> &lt;T&gt;</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; T <span class="hljs-title function_">getInstance</span><span class="hljs-params">(Class&lt;?&gt; tClass, String key)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">tClassName</span> <span class="hljs-operator">=</span> tClass.getName();<br>        Map&lt;String, Class&lt;?&gt;&gt; keyClassMap = loaderMap.get(tClassName);<br>        <span class="hljs-keyword">if</span> (keyClassMap == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(String.format(<span class="hljs-string">&quot;SpiLoader 未加载 %s 类型&quot;</span>, tClassName));<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!keyClassMap.containsKey(key)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(String.format(<span class="hljs-string">&quot;SpiLoader 的 %s 不存在 key=%s 的类型&quot;</span>, tClassName, key));<br>        &#125;<br>        <span class="hljs-comment">// 获取到要加载的实现类型</span><br>        Class&lt;?&gt; implClass = keyClassMap.get(key);<br>        <span class="hljs-comment">// 从实例缓存中加载指定类型的实例</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">implClassName</span> <span class="hljs-operator">=</span> implClass.getName();<br>        <span class="hljs-keyword">if</span> (!instanceCache.containsKey(implClassName)) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                instanceCache.put(implClassName, implClass.newInstance());<br>            &#125; <span class="hljs-keyword">catch</span> (InstantiationException | IllegalAccessException e) &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">errorMsg</span> <span class="hljs-operator">=</span> String.format(<span class="hljs-string">&quot;%s 类实例化失败&quot;</span>, implClassName);<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(errorMsg, e);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (T) instanceCache.get(implClassName);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 加载某个类型</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> loadClass</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Map&lt;String, Class&lt;?&gt;&gt; load(Class&lt;?&gt; loadClass) &#123;<br>        log.info(<span class="hljs-string">&quot;加载类型为 &#123;&#125; 的 SPI&quot;</span>, loadClass.getName());<br>        <span class="hljs-comment">// 扫描路径，用户自定义的 SPI 优先级高于系统 SPI</span><br>        Map&lt;String, Class&lt;?&gt;&gt; keyClassMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (String scanDir : SCAN_DIRS) &#123;<br>            List&lt;URL&gt; resources = ResourceUtil.getResources(scanDir + loadClass.getName());<br>            <span class="hljs-comment">// 读取每个资源文件</span><br>            <span class="hljs-keyword">for</span> (URL resource : resources) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-type">InputStreamReader</span> <span class="hljs-variable">inputStreamReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(resource.openStream());<br>                    <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">bufferedReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(inputStreamReader);<br>                    String line;<br>                    <span class="hljs-keyword">while</span> ((line = bufferedReader.readLine()) != <span class="hljs-literal">null</span>) &#123;<br>                        String[] strArray = line.split(<span class="hljs-string">&quot;=&quot;</span>);<br>                        <span class="hljs-keyword">if</span> (strArray.length &gt; <span class="hljs-number">1</span>) &#123;<br>                            <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> strArray[<span class="hljs-number">0</span>];<br>                            <span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> strArray[<span class="hljs-number">1</span>];<br>                            keyClassMap.put(key, Class.forName(className));<br>                        &#125;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    log.error(<span class="hljs-string">&quot;spi resource load error&quot;</span>, e);<br>                &#125;<br>            &#125;<br>        &#125;<br>        loaderMap.put(loadClass.getName(), keyClassMap);<br>        <span class="hljs-keyword">return</span> keyClassMap;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="4-扩展思路"><a href="#4-扩展思路" class="headerlink" title="4.扩展思路"></a>4.扩展思路</h2><ul>
<li>实现更多不同协议的序列化器</li>
</ul>
<p>参考思路：由于序列化是单例，要注意序列化器的线程安全性（如kryo），可以使用ThreadLocal</p>
<ul>
<li>序列化器工厂可以使用懒加载（懒汉式单例）的方式创建序列化器实例。</li>
</ul>
<p>参考思路：目前是通过static静态代码块初始化的</p>
<ul>
<li>SPI Loader支持懒加载，获取实例时才加载对应的类</li>
</ul>
<p>参考思路：可以使用双检锁单例模式</p>
<h1 id="四、注册中心基本实现"><a href="#四、注册中心基本实现" class="headerlink" title="四、注册中心基本实现"></a>四、注册中心基本实现</h1><h2 id="1-需求分析-3"><a href="#1-需求分析-3" class="headerlink" title="1.需求分析"></a>1.需求分析</h2><p>RPC框架的一个核心模是注册中心，目的是帮助服务消费者获取到服务提供者的调用地址，而不是将调用地址硬编码到项目中，流程如下：</p>
<p class='item-img' data-src='C:\Users\新\AppData\Roaming\Typora\typora-user-images\image-20241008213733155.png'><img src="C:\Users\新\AppData\Roaming\Typora\typora-user-images\image-20241008213733155.png" alt="image-20241008213733155"></p>
<p>本节实现一个具有基本功能的注册中心，跑通注册中心的流程，之后再优化</p>
<h2 id="2-设计方案-3"><a href="#2-设计方案-3" class="headerlink" title="2.设计方案"></a>2.设计方案</h2><p>注册中心的核心能力：</p>
<ol>
<li>数据分布式存储：集中的注册信息数据存储、读取和共享</li>
<li>服务注册：服务提供者上报服务信息到注册中心</li>
<li>服务发现：服务消费者从注册中心拉取服务信息</li>
<li>心跳检测：定期检查服务提供者的存活状态</li>
<li>服务注销：手动剔除节点，或者自动剔除失效节点</li>
<li>更多优化点：比如注册中心本身的容错、服务消费者缓存等</li>
</ol>
<h3 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h3><p>明确注册中心的功能之后，我们可以根据这些能力进行技术选型。</p>
<p>第一点是最重要的，需要一个能集中存储和读取数据的中间件。此外，还需要有数据过期、数据监听的功能，便于我们移除失效节点，更新节点列表等。</p>
<p>此外，对于注册中心的技术选型，我们还要考虑它的性能、高可用性、高可靠性、稳定性、数据一致性、社区的生态和活跃度等。注册中心的可用性和可靠性尤其重要。</p>
<p>主流的注册中心实现中间件有ZooKeeper、Redis等，本项目使用<code>Etcd云原生中间件</code>来实现注册中心</p>
<h4 id="Etcd入门"><a href="#Etcd入门" class="headerlink" title="Etcd入门"></a>Etcd入门</h4><p>go语言实现、开源、分布式的键值存储系统。它主要用于分布式系统中的服务发现、配置管理和分布式锁等场景。经典的容器管理平台k8s就使用了Etcd来存储集群配置信息、状态信息、节点信息等。</p>
<p>不仅性能高，其采用Raft一致性算法来保证数据的一致性和可靠性，具有高可用性，强一致性、分布式特性等特点</p>
<p>简单易用，提供了简单API、数据的过期机制、数据监听和通知机制等，完美满足注册中心的实现诉求。</p>
<h4 id="Etcd数据结构与特性"><a href="#Etcd数据结构与特性" class="headerlink" title="Etcd数据结构与特性"></a>Etcd数据结构与特性</h4><p>Etcd在其数据模型和组织结构上更接近于ZooKeeper和对象存储，而不是redis.它使用层次化的键值对来存储数据，支持类似于的文件系统的层次结构，能够灵活地单key查询、按前缀查询、按范围查询</p>
<p>如下图：**<code>注意使用该命令启动etcd：./etcd -listen-client-urls=&quot;http://0.0.0.0:2379&quot; --advertise-client-urls=&quot;http://0.0.0.0:2379&quot;</code>**</p>
<p class='item-img' data-src='C:\Users\新\AppData\Roaming\Typora\typora-user-images\image-20241008221655718.png'><img src="C:\Users\新\AppData\Roaming\Typora\typora-user-images\image-20241008221655718.png" alt="image-20241008221655718"></p>
<p>Etcd的核心数据结构包括：</p>
<ol>
<li>Key（键）：基本数据单元，类似于文件系统中的文件名，每个键都唯一标识一个值，并且可以包含子键，形成类似于路径的层次结构</li>
<li>Value（值）：与键关联的数据，可以是任意类型的数据，通常是字符串形式</li>
</ol>
<p>其有很多核心特性，其中，应用较多的特性是：</p>
<ol>
<li>Lease（租约）：用于对键值对进行TTL超时设置，即设置键值对的过期时间。当租约过期时，相关的键值对将被自动删除</li>
<li>Watch（监听）：可以监视特定键的变化，当键的值发生变化时，会触发相应的通知</li>
</ol>
<p>如何保持数据一致性？</p>
<p>从表层来看：其支持事务操作，能够保证数据的一致性</p>
<p>从底层来看：使用Raft一致性算法来保证数据的一致性</p>
<p>Raft是一种分布式一致性算法：它确保分布式系统中的所有节点在任何时间点都能达成一致的数据视图</p>
<p>具体来说，Raft算法通过选举机制选举出一个领导者节点，领导者负责接收客户端的写请求，并将写操作复制到其它节点上。</p>
<p>当客户端发送请求时，领导者首先将写操作写入自己的日志中，并将写操作的日志条目分发给其它节点，其它节点收到日志后也将其写入自己的日志中，一旦<strong>大多数节点</strong>（半数以上的节点）都将该日志条目成功写入到自己的日志中，该日志条目就被视为已提交，领导者会向客户端发送成功响应。在领导者发送成功响应后，该写操作就被视为已提交，从而保证了数据的一致性。</p>
<p>如果领导者宕机或失去联系，该算法会在其它节点中<code>选举出新的领导者</code>，从而保证系统的可用性和一致性。新的领导者会继续接收客户端的写请求，并负责将写操作复制到其它节点上，从而保证数据的一致性。</p>
<p>此处可以通过官方提供的Playgroud来可视化操作Etcd，便于学习：<a target="_blank" rel="noopener" href="http://play.etcd.io/play">Playgroud网址</a></p>
<p>Etcd Java客户端</p>
<p>所谓客户端，就是操作Etcd的工具</p>
<p>etcd主流的java客户端是jetcd<a target="_blank" rel="noopener" href="https://github.com/etcd-io/jetcd">java操作工具</a></p>
<p>1）首先在项目中引入jetcd:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs maven">&lt;!-- https://mvnrepository.com/artifact/io.etcd/jetcd-core --&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;io.etcd&lt;/groupId&gt;<br>    &lt;artifactId&gt;jetcd-core&lt;/artifactId&gt;<br>    &lt;version&gt;0.7.7&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure>

<p>2）官方demo</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yupi.yurpc.registry;<br><br><span class="hljs-keyword">import</span> io.etcd.jetcd.ByteSequence;<br><span class="hljs-keyword">import</span> io.etcd.jetcd.Client;<br><span class="hljs-keyword">import</span> io.etcd.jetcd.KV;<br><span class="hljs-keyword">import</span> io.etcd.jetcd.kv.GetResponse;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.CompletableFuture;<br><span class="hljs-keyword">import</span> java.util.concurrent.ExecutionException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EtcdRegistry</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br>        <span class="hljs-comment">// create client using endpoints</span><br>        <span class="hljs-type">Client</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> Client.builder().endpoints(<span class="hljs-string">&quot;http://localhost:2379&quot;</span>)<br>                .build();<br><br>        <span class="hljs-type">KV</span> <span class="hljs-variable">kvClient</span> <span class="hljs-operator">=</span> client.getKVClient();<br>        <span class="hljs-type">ByteSequence</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> ByteSequence.from(<span class="hljs-string">&quot;test_key&quot;</span>.getBytes());<br>        <span class="hljs-type">ByteSequence</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> ByteSequence.from(<span class="hljs-string">&quot;test_value&quot;</span>.getBytes());<br><br>        <span class="hljs-comment">// put the key-value</span><br>        kvClient.put(key, value).get();<br><br>        <span class="hljs-comment">// get the CompletableFuture</span><br>        CompletableFuture&lt;GetResponse&gt; getFuture = kvClient.get(key);<br><br>        <span class="hljs-comment">// get the value from CompletableFuture</span><br>        <span class="hljs-type">GetResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> getFuture.get();<br><br>        <span class="hljs-comment">// delete the key</span><br>        kvClient.delete(key).get();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上述代码中，我们使用KVClient来操作Etcd写入和读取数据，除了KVClient客户端之外，其还提供很多其它客户端，常用的客户端和作用如下，了解即可：</p>
<ol>
<li>KVClient：用于对etcd中键值对进行操作，通过KVClient可以进行设置，获取值，删除值，列出目录等操作</li>
<li>leaseClient：用于管理etcd的租约机制。租约是etcd中的一种时间片，用于为键值对分配生存时间，并在租约到期时自动删除相关的键值对，通过leaseClient 可以创建、获取、续约和撤销租约</li>
<li>watchClient：用于监视etcd中键的变化，并在键的值发生变化时接收通知</li>
<li>clusterClient：用于与etcd的集群进行交互，包括添加、移除、列出成员、设置选举、获取集群的健康状态、获取成员列表信息等操作</li>
<li>authClient：用于管理etcd的身份验证和授权。通过authClient可以添加、删除、列出用户、角色等身份信息，以及授予或撤销用户或角色的权限</li>
<li>maintenanceClient：用于执行etcd的维护操作、如健康检查、数据库备份、成员维护、数据库快照、数据库压缩等</li>
<li>lockClient：用于实现分布式锁功能，通过lockClient可以在etcd上创建、获取和释放锁，能够轻松实现并发控制</li>
<li>electionClient：用于实现分布式选举功能，可以在etcd上创建选举、提交选票、监视选举结果等。</li>
</ol>
<p><strong><code>绝大多是情况下，使用前面三个客户端就足够了</code></strong></p>
<p>使用debug执行上诉代码，观察etcd的数据结构，如图：</p>
<p class='item-img' data-src='C:\Users\新\AppData\Roaming\Typora\typora-user-images\image-20241010224416891.png'><img src="C:\Users\新\AppData\Roaming\Typora\typora-user-images\image-20241010224416891.png" alt="image-20241010224416891"></p>
<p>发现除了key和value外，还能看到版本、创建版本、修改版本字段。这是因为etcd中的每个键都有一个与之关联的版本号，用于跟踪键的修改历史。每当一个键的值发生改变时，其版本号也会增加。</p>
<p>通过使用etcd的Watch API，<strong>可以监视键的变化，并在变化时接收通知</strong>。这种版本机制使得etcd在分布式系统中能够实现<strong>乐观并发控制、一致性和可靠性</strong>的数据访问</p>
<h3 id="存储结构设计"><a href="#存储结构设计" class="headerlink" title="存储结构设计"></a>存储结构设计</h3><ol>
<li>key如何设计？</li>
<li>value如何设计？</li>
<li>key什么时候过期？</li>
</ol>
<p>由于一个服务可能有多个服务提供者（负载均衡），我们可以有两种结构设计：</p>
<ul>
<li>层级结构：将服务理解为多个文件夹，将服务对应的多个节点理解为文件夹下的文件，那么可以通过服务名称，用前缀查询的方法查询到某个服务的所有节点</li>
</ul>
<p>如图，键名的规则可以是：<code>/业务前缀/服务名/服务节点地址</code></p>
<p class='item-img' data-src='C:\Users\新\AppData\Roaming\Typora\typora-user-images\image-20241010225101481.png'><img src="C:\Users\新\AppData\Roaming\Typora\typora-user-images\image-20241010225101481.png" alt="image-20241010225101481"></p>
<ul>
<li>列表结构：将所有的服务节点以列表的形式整体作为value</li>
</ul>
<p>如图：</p>
<p class='item-img' data-src='C:\Users\新\AppData\Roaming\Typora\typora-user-images\image-20241010225149249.png'><img src="C:\Users\新\AppData\Roaming\Typora\typora-user-images\image-20241010225149249.png" alt="image-20241010225149249"></p>
<p>选择哪种存储结构？跟我们的技术选型有关。对于Zookeeper和etcd这种支持层级查询的中间件，用第一种结构会更清晰，对于redis，由于本身就支持列表数据结构，可以选择第二种结构</p>
<p>最后，一定要给key设置过期时间，比如默认30s过期，这样如果服务提供者宕机了，也可以超时后自动移除</p>
<h2 id="3-开发实现-2"><a href="#3-开发实现-2" class="headerlink" title="3.开发实现"></a>3.开发实现</h2><h3 id="注册中心开发"><a href="#注册中心开发" class="headerlink" title="注册中心开发"></a>注册中心开发</h3><ul>
<li>注册信息定义</li>
<li>注册中心配置</li>
<li>注册中心接口</li>
<li>Etcd注册中心实现</li>
</ul>
<h1 id="五、注册中心优化"><a href="#五、注册中心优化" class="headerlink" title="五、注册中心优化"></a>五、注册中心优化</h1><h2 id="1-需求分析-4"><a href="#1-需求分析-4" class="headerlink" title="1.需求分析"></a>1.需求分析</h2><p>上一节完成了注册中心基础功能，能够注册和获取服务和节点信息</p>
<p>但目前系统仅仅是处于可用的程度，还有很多需要解决的问题和可优化的点：</p>
<p>1.数据一致性：服务提供者如果下线了，注册者需要即时更新，剔除下线的节点，否则消费者可能会调用到下线的节点</p>
<p>2.性能优化：服务消费者每次都需要从注册中心获取服务，可以使用缓存进行优化</p>
<p>3.高可用性：保证注册中心本身不会宕机</p>
<p>4.可扩展性：实现更多其它种类的注册中心</p>
<p>本节主要实现4个注册中心的优化点：</p>
<ol>
<li>心跳检测和续期机制</li>
<li>服务节点下线机制</li>
<li>消费端服务缓存</li>
<li>基于ZooKeeper的注册中心的实现</li>
</ol>
<h2 id="2-注册中心优化"><a href="#2-注册中心优化" class="headerlink" title="2.注册中心优化"></a>2.注册中心优化</h2><h3 id="心跳检测和续期机制"><a href="#心跳检测和续期机制" class="headerlink" title="心跳检测和续期机制"></a>心跳检测和续期机制</h3><p>心跳检测介绍</p>
<p>这是一种用于检测系统是否正常工作的机制。它通过定期发送<strong>心跳信号</strong>（请求）来检测目标系统的状态</p>
<p>如果接收方在一定时间内没有收到心跳信号或者未能正常响应请求，就会认为目标系统故障或不可用，从而触发响应的处理或告警机制</p>
<p>心跳检测的应用场景非常广泛，尤其在分布式，微服务系统中，比如集群、服务健康检查等。</p>
<p>场景：检测自己做的web后端是否正常运行？</p>
<p>一个最简单的方法就是写一个心跳检测接口，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HealthCheckController</span> &#123;<br><br>    <span class="hljs-comment">// 健康检查接口</span><br>    <span class="hljs-meta">@GetMapping(&quot;/actuator/health&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">healthCheck</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 在这里可以添加其他健康检查逻辑，例如检查数据库连接、第三方服务等</span><br><br>        <span class="hljs-comment">// 返回一个简单的健康状态</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;OK&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>然后我们只需要执行一个脚本，定期调用这个接口，如果调用失败了，就知道系统故障了</p>
<h4 id="方案设计"><a href="#方案设计" class="headerlink" title="方案设计"></a>方案设计</h4><ul>
<li>从心跳检测的概念来看，实现心跳检测一般需要俩个关键：定时、网络请求</li>
</ul>
<p>但是使用Etcd实现心跳检测会更简单一些，因为Etcd自带了key过期机制，不妨换个思路：给节点注册信息一个“生命倒计时”，让节点定期<strong>续期</strong>，重置<strong>自己的</strong>倒计时，如果节点已宕机，一直不续期，Etcd就会对key进行过期删除。</p>
<p>一句话总结：到时间还不续期就是宕机了</p>
<p>在Etcd中，实现心跳检测和续期机制，可以遵循如下步骤：</p>
<ol>
<li>服务提供者向Etcd注册自己的服务信息，并在注册时设置TTL（生存时间）</li>
<li>Etcd在接收到服务提供者的注册信息后，会自动维护服务信息的TTL，并在TTL过期时删除该服务的信息</li>
<li>服务提供者定期请求Etcd续签自己的注册信息，重写TTL</li>
</ol>
<p>注意：续期时间一定要小于过期时间，允许一次容错的机会</p>
<ul>
<li>每个服务提供者都需要找到自己注册的节点，续期自己的节点，但问题是，怎么找到当前服务提供者项目自己的节点？</li>
</ul>
<p>充分利用本地的特性，在服务提供者本地维护一个<strong>已注册节点集合</strong>，注册时添加节点key到集合中，只需要续期集合内的key即可</p>
<h4 id="开发实现-1"><a href="#开发实现-1" class="headerlink" title="开发实现"></a>开发实现</h4><ol>
<li>给注册中心<code>Register</code>接口补充心跳检测方法</li>
<li>维护续期节点集合</li>
<li>在<code>EtcdRegister</code>中实现heartBeat方法：可以使用Hutool工具类中的CronUtil实现定时任务，对所有集合中的节点执行<strong>重新注册</strong>操作，这是一个小trick，就相当于续签了。这样的好处是，就算Etcd注册中心的数据出现了丢失，通过心跳检测机制也会重新注册节点信息</li>
<li>开启hearBeat：在初始化方法<code>init</code>中直接调用<code>heatBeat</code>即可</li>
</ol>
<h4 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h4><h3 id="服务节点下线机制"><a href="#服务节点下线机制" class="headerlink" title="服务节点下线机制"></a>服务节点下线机制</h3><p>当服务提供者节点宕机时，应该从注册中心移除已注册的节点，否则会影响消费端调用。所以我们需要设计一套服务节点下线机制</p>
<h4 id="方案设计-1"><a href="#方案设计-1" class="headerlink" title="方案设计"></a>方案设计</h4><p>服务节点下线又分为：</p>
<ul>
<li>主动下线：服务提供者项目正常退出时，主动从注册中心移除注信息</li>
<li>被动下线：服务提供者项目异常退出时，利用Etcd的key过期机制自动移除</li>
</ul>
<p>被动下线已经可以利用Etcd的机制实现了，我们主要开发主动下线</p>
<p>问题：怎么在java项目正常退出时，执行某个程序呢？</p>
<p>利用<code>JVM的ShutdownHock</code>就能实现，JVM的ShutdownHock是虚拟机提供的一种机制，允许开发者在JVM即将关闭之前执行一些清理工作或其它必要的操作，例如关闭数据库连接、释放资源、保存临时数据等</p>
<p><code>Spring Boot也提供了类似的优雅停机的能力。</code></p>
<h4 id="开发实现-2"><a href="#开发实现-2" class="headerlink" title="开发实现"></a>开发实现</h4><ul>
<li><p>完善Etcd注册中心的<code>destory</code>方法，补充下线节点的逻辑</p>
</li>
<li><p>在<code>RpcApplication</code>的<code>init</code>方法中，注册<code>Shutdown Hook</code>，当程序正常退出时会执行注册中心的<code>destory</code>方法</p>
</li>
</ul>
<h4 id="测试-3"><a href="#测试-3" class="headerlink" title="测试"></a>测试</h4><ol>
<li>启动服务提供者，然后观察服务是否成功被注册</li>
<li>正常停止服务提供者，然后观察服务信息是否被删除</li>
</ol>
<h3 id="消费端服务缓存"><a href="#消费端服务缓存" class="headerlink" title="消费端服务缓存"></a>消费端服务缓存</h3><p>正常情况下，服务节点信息列表的更新频率是不高的，所以在服务消费者从注册中心获取到服务节点信息列表后，完全可以<strong>缓存到本地</strong>， 下次就不用再请求注册中心获取了，能够提高性能</p>
<h4 id="增加本地缓存"><a href="#增加本地缓存" class="headerlink" title="增加本地缓存"></a>增加本地缓存</h4><p>本地缓存的实现很简单，用一个列表来存储服务信息即可，提供操作列表的基本方法，包括：写缓存、读缓存、清空缓存</p>
<p>注意：本教程只考虑单服务（相同serviceKey）的缓存。如果要实现多服务缓存可以改为使用Map接口，参考本次提交的代码：<a target="_blank" rel="noopener" href="https://github.com/liyupi/yu-rpc/commit/c420222f4673114ee760b7875d68635902625ce9">超链接</a></p>
<h4 id="使用本地缓存"><a href="#使用本地缓存" class="headerlink" title="使用本地缓存"></a>使用本地缓存</h4><h4 id="服务缓存更新-监听机制"><a href="#服务缓存更新-监听机制" class="headerlink" title="服务缓存更新-监听机制"></a>服务缓存更新-监听机制</h4><p>当服务注册信息发生变更（比如节点下线）时，需要即时更新消费端缓存</p>
<p>问题是，怎么知道服务注册信息什么时候发生变更呢？</p>
<p>这就需要我们使用Etcd的watch监听机制，当监听的某个key发生修改或删除时，就会触发事件来通知监听者。如图：</p>
<p class='item-img' data-src='C:\Users\新\AppData\Roaming\Typora\typora-user-images\image-20241015213854354.png'><img src="C:\Users\新\AppData\Roaming\Typora\typora-user-images\image-20241015213854354.png" alt="image-20241015213854354"></p>
<p>什么时候去创建监听器？</p>
<p>首先明确watch监听是服务消费者还是服务提供者执行的。由于我们的目标是更新缓存，缓存是在服务消费端维护和使用的，所以也应该是服务消费端去watch</p>
<p>也就是说，只有服务消费者执行的方法中，可以创建watch监听器，那么比较合适的位置就是服务发现方法（serviceDiscovery）。可以对本次获取到的所有服务节点key进行监听。</p>
<p>还需要防止重复监听同一个key,可以通过定义一个已监听key的集合来实现</p>
<h4 id="测试-4"><a href="#测试-4" class="headerlink" title="测试"></a>测试</h4><ol>
<li>先启动服务提供者</li>
<li>修改服务消费者项目，连续调用服务3次， 通过debug可以发现。第一次查注册中心、第二次查询缓存</li>
<li>在第三次要调用服务时，下线服务提供者，可以看到注册中心的节点的注册key已被删除</li>
<li>继续向下执行，发现第三次调用服务时，又重新从注册中心查询，说明缓存已被更新</li>
</ol>
<p>至此，消费端服务缓存功能已经完成！</p>
<h2 id="3-Zookeeper注册中心实现（非重点）"><a href="#3-Zookeeper注册中心实现（非重点）" class="headerlink" title="3.Zookeeper注册中心实现（非重点）"></a>3.Zookeeper注册中心实现（非重点）</h2><p>其实和Etcd注册中心实现的方式极其相似</p>
<p>具体实现见编程导航</p>
<h2 id="4-扩展"><a href="#4-扩展" class="headerlink" title="4.扩展"></a>4.扩展</h2><ul>
<li>完善服务注册信息</li>
</ul>
<p>参考思路：比如增加节点注册时间</p>
<ul>
<li>实现更多注册中心。（较难）</li>
</ul>
<p>参考思路：使用redis实现注册中心</p>
<ul>
<li>保证注册中心的高可用</li>
</ul>
<p>参考思路：了解Etcd的集群机制</p>
<ul>
<li>服务注册信息失效的兜底策略（较难）</li>
</ul>
<p>参考思路：如果消费端调用节点时发现节点失效，也可以考虑是否需要从注册中心更新服务注册信息，或者强制更新本地缓存</p>
<ul>
<li>注册中心监听key时，采用观察者模式实现处理</li>
</ul>
<p>参考思路：可以的定义一个Listener接口，根据watch key的变更类型去调用Listener的不同方法</p>
<h1 id="六、自定义协议"><a href="#六、自定义协议" class="headerlink" title="六、自定义协议"></a>六、自定义协议</h1><h2 id="1-需求分析-5"><a href="#1-需求分析-5" class="headerlink" title="1.需求分析"></a>1.需求分析</h2><p>目前的RPC框架，我们使用vert.x的httpServer作为服务提供者的服务器，代码实现比较简单，其底层网络传输使用的是HTTP协议</p>
<p>那么http会有什么问题？或者说有没有更好的选择？</p>
<p>一般情况下，Rpc框架会比较注重性能，而HTTP协议中的头部信息、请求响应格式比较“重”，会影响网络传输性能。</p>
<p>所以，我们需要自己定义一套RPC协议，比如利用Tcp等传输层协议，自定义请求响应结构，来实现性能更高，更灵活、更安全的RPC框架</p>
<h2 id="2-设计方案-4"><a href="#2-设计方案-4" class="headerlink" title="2.设计方案"></a>2.设计方案</h2><p>自定义RPC协议可以分为2大核心部分：</p>
<ul>
<li>自定义网络传输</li>
<li>自定义消息结构</li>
</ul>
<h3 id="网络传输协议"><a href="#网络传输协议" class="headerlink" title="网络传输协议"></a>网络传输协议</h3><p>网络传输设计的目标是：选择一个能够高性能通信的网络协议和传输方式</p>
<p>需求分析中已经提到：http的头部信息是比较大的，会影响传输性能。但除了这点，http本身属于无状态协议，这意味着每个http请求都是独立的，每次请求&#x2F;响应都要重新建立和关闭连接，也会影响性能。</p>
<p><code>无状态协议：每个请求都是独立的，两个请求之前不会有任何联系，因此每次请求都需要足够的信息来保证能正常处理请求和响应</code></p>
<p>考虑到这点，Http&#x2F;1.1中引入了持久连接(keep-alive)，允许在单个TCP连接上发送多个HTtp请求和响应，避免了每次请求都要重新建立和关闭连接的开销</p>
<p>虽然如此，http本身是应用层协议，我们现在设计的RPC协议也是应用层协议，性能肯定是不如底层（传输层）的TCP协议要高的，因此要想追求更高的性能，还是选择TCP协议完成网络传输，这样也有更多的自主设计空间</p>
<h2 id="消息结构设计"><a href="#消息结构设计" class="headerlink" title="消息结构设计"></a>消息结构设计</h2><p>消息结构设计的目标是：用<code>最少的</code>空间传递<code>需要的</code>信息</p>
<ul>
<li>如何使用最少的空间？</li>
</ul>
<p>大家之前接触的数据类型可能都是整型、长整型、浮点数等，这些类型其实都比较“重”，占用的字节数较多，比如整型要占用4个字节，32个bit位</p>
<p>在自定义消息结构时，想要节省空间，要尽可能使用更轻量的类型，比如byte字节类型，只占用1个字节，8个bit位</p>
<p>需要注意的是，java实现bit位运算拼接相对比较麻烦，所以权衡开发成本，设计消息结构时，尽量给每个数据凑到整个字节</p>
<ul>
<li>消息内需要哪些信息呢？</li>
</ul>
<p>目标肯定能够完成请求，可以从http中找到一些线索</p>
<p>分析http请求，我们能够得到RPC消息所需的信息：</p>
<ol>
<li>魔数：作用是安全校验，防止服务器处理了非框架发来的其它信息（类似https证书）</li>
<li>版本号：保证请求和响应的一致性（类似http协议有1.0&#x2F;2.0版本）</li>
<li>序列化方式：告诉服务端和客户端如何解析数据（类似HTTP的Content-Type内容类型）</li>
<li>类型：标识是请求还是响应？或者是心跳检测还是其它用途（类似HTTP有请求头和响应头）</li>
<li>状态：如果是响应，记录响应的结果（类似HTTP的200状态码）</li>
</ol>
<p>此外，还有请求id，唯一标识某个请求，因为TCP是双向通信的，需要有个唯一标识来追踪每个请求。</p>
<p>最后，也是最重要的，要发送body数据内容，我们暂时称它为<code>请求体</code>，类似我们之前HTTP请求中发送的RpcRequest</p>
<p>如果是HTTP这种协议，有专门的key&#x2F;value结构，很容易找完整的body数据，但是基于TCP协议，想要获取完整的bod内容数据，就需要一些“小心思”了，因为TCP协议本身会存在半包和粘包问题，每次传输的数据可能是不完整的</p>
<p>所以我们需要在消息头中新增一个字段<code>请求体数据长度</code>，保证能够完整地获取body中的内容数据</p>
<p>基于以上考虑，我们可以得到最终的消息结构设计，如图：</p>
<p class='item-img' data-src='C:\Users\新\AppData\Roaming\Typora\typora-user-images\image-20241016223911826.png'><img src="C:\Users\新\AppData\Roaming\Typora\typora-user-images\image-20241016223911826.png" alt="image-20241016223911826"></p>
<p>实际上，这些数据应该是紧凑的，请求头总长17个字节，也就是说上述的消息结构，本质上就是拼接在一起的一个字节数组。我们后续实现时，需要消息编码器和消息解码器，编码器先new 一个空的Buffer缓冲区，然后按照顺序向缓冲区依次写入这些数据；解码器在读取的时候也按照顺序依次读取</p>
<p>通过这种约定方式，我们就不用记录头部信息了。比如magic魔数，不用存储“magic”这个字符串，而是读取第一个字节就能获取到</p>
<h2 id="3-开发实现-3"><a href="#3-开发实现-3" class="headerlink" title="3.开发实现"></a>3.开发实现</h2><h3 id="消息结构"><a href="#消息结构" class="headerlink" title="消息结构"></a>消息结构</h3><ul>
<li>新建协议消息类<code>ProtocolMessage</code>：将消息头单独封装为一个内部类，消息体可以使用泛型类型</li>
<li>新建协议常量类<code>ProtocolConstant</code>：记录了和自定义协议有关的关键信息，比如消息头长度、魔数、版本号</li>
<li>新建消息字段的枚举类：协议状态枚举，暂时只定义成功、请求失败、响应失败三种枚举值</li>
</ul>
<h3 id="网络传输"><a href="#网络传输" class="headerlink" title="网络传输"></a>网络传输</h3><p>RPC框架使用了高性能的Vert.x作为网络传输服务器，之前用的是 HttpServer，同样， Vert.x也支持TCP服务器，相比于Netty或者自己写的Socket代码，更加简单易用</p>
<p>首先新建<code>server.tcp</code>包，将所有TCP服务相关的代码放到该包中</p>
<ul>
<li>TCP服务器实现、</li>
<li>TCP客户端实现</li>
<li>测试</li>
</ul>
<h3 id="编码-解码"><a href="#编码-解码" class="headerlink" title="编码&#x2F;解码"></a>编码&#x2F;解码</h3><p>vert.x的TCP服务器收发的消息是Buffer类型，不能直接写入一个对象。因此，我们需要编码器和解码器。将java的消息对象和buffer进行相互转换</p>
<p class='item-img' data-src='C:\Users\新\AppData\Roaming\Typora\typora-user-images\image-20241017230154386.png'><img src="C:\Users\新\AppData\Roaming\Typora\typora-user-images\image-20241017230154386.png" alt="image-20241017230154386"></p>
<p>之前http请求和响应时，直接从请求body处理器中获取到body字节数组，再通过序列化（反序列化）得到RpcRequest或RpcResponse对象。使用TCP服务器后，只不过改为从Buffer中获取字节数组，然后编解码为RpcRequest和RpcResponse对象。其它后续处理流程都是可复用的</p>
<ul>
<li>首先实现消息编码器</li>
<li>实现消息解码器</li>
<li>测试</li>
</ul>
<h2 id="4-粘包半包问题解决"><a href="#4-粘包半包问题解决" class="headerlink" title="4.粘包半包问题解决"></a>4.粘包半包问题解决</h2><h3 id="什么是粘包和半包？："><a href="#什么是粘包和半包？：" class="headerlink" title="什么是粘包和半包？："></a>什么是粘包和半包？：</h3><p>使用TCP协议网络通讯时，可能会出现半包和粘包问题。</p>
<p>1）每次收到的数据更少了，这种情况叫做<code>半包</code></p>
<p>2）每次收到的数据更多了，这种情况叫做<code>粘包</code></p>
<h3 id="半包粘包问题的演示"><a href="#半包粘包问题的演示" class="headerlink" title="半包粘包问题的演示"></a>半包粘包问题的演示</h3><p>1）修改TCP客户端代码，连续发送1000次消息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yupi.yurpc.server.tcp;<br><br><span class="hljs-keyword">import</span> io.vertx.core.Vertx;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VertxTcpClient</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 创建 Vert.x 实例</span><br>        <span class="hljs-type">Vertx</span> <span class="hljs-variable">vertx</span> <span class="hljs-operator">=</span> Vertx.vertx();<br><br>        vertx.createNetClient().connect(<span class="hljs-number">8888</span>, <span class="hljs-string">&quot;localhost&quot;</span>, result -&gt; &#123;<br>            <span class="hljs-keyword">if</span> (result.succeeded()) &#123;<br>                System.out.println(<span class="hljs-string">&quot;Connected to TCP server&quot;</span>);<br>                io.vertx.core.net.<span class="hljs-type">NetSocket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> result.result();<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>                    <span class="hljs-comment">// 发送数据</span><br>                    socket.write(<span class="hljs-string">&quot;Hello, server!Hello, server!Hello, server!Hello, server!&quot;</span>);<br>                &#125;<br>                <span class="hljs-comment">// 接收响应</span><br>                socket.handler(buffer -&gt; &#123;<br>                    System.out.println(<span class="hljs-string">&quot;Received response from server: &quot;</span> + buffer.toString());<br>                &#125;);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                System.err.println(<span class="hljs-string">&quot;Failed to connect to TCP server&quot;</span>);<br>            &#125;<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">VertxTcpClient</span>().start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>2）修改TCP服务端代码，打印每次收到的消息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yupi.yurpc.server.tcp;<br><br><span class="hljs-keyword">import</span> com.yupi.yurpc.server.HttpServer;<br><span class="hljs-keyword">import</span> io.vertx.core.Vertx;<br><span class="hljs-keyword">import</span> io.vertx.core.net.NetServer;<br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VertxTcpServer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HttpServer</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doStart</span><span class="hljs-params">(<span class="hljs-type">int</span> port)</span> &#123;<br>        <span class="hljs-comment">// 创建 Vert.x 实例</span><br>        <span class="hljs-type">Vertx</span> <span class="hljs-variable">vertx</span> <span class="hljs-operator">=</span> Vertx.vertx();<br><br>        <span class="hljs-comment">// 创建 TCP 服务器</span><br>        <span class="hljs-type">NetServer</span> <span class="hljs-variable">server</span> <span class="hljs-operator">=</span> vertx.createNetServer();<br><br>        <span class="hljs-comment">// 处理请求</span><br><span class="hljs-comment">//        server.connectHandler(new TcpServerHandler());</span><br>        server.connectHandler(socket -&gt; &#123;<br>            socket.handler(buffer -&gt; &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">testMessage</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello, server!Hello, server!Hello, server!Hello, server!&quot;</span>;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">messageLength</span> <span class="hljs-operator">=</span> testMessage.getBytes().length;<br>                <span class="hljs-keyword">if</span> (buffer.getBytes().length &lt; messageLength) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;半包, length = &quot;</span> + buffer.getBytes().length);<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (buffer.getBytes().length &gt; messageLength) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;粘包, length = &quot;</span> + buffer.getBytes().length);<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buffer.getBytes(<span class="hljs-number">0</span>, messageLength));<br>                System.out.println(str);<br>                <span class="hljs-keyword">if</span> (testMessage.equals(str)) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;good&quot;</span>);<br>                &#125;<br>            &#125;);<br>        &#125;);<br><br>        <span class="hljs-comment">// 启动 TCP 服务器并监听指定端口</span><br>        server.listen(port, result -&gt; &#123;<br>            <span class="hljs-keyword">if</span> (result.succeeded()) &#123;<br>                log.info(<span class="hljs-string">&quot;TCP server started on port &quot;</span> + port);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                log.info(<span class="hljs-string">&quot;Failed to start TCP server: &quot;</span> + result.cause());<br>            &#125;<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">VertxTcpServer</span>().doStart(<span class="hljs-number">8888</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>3）测试运行，查看服务端控制台，发现服务端接收消息时，出现半包和粘包</p>
<p class='item-img' data-src='C:\Users\新\AppData\Roaming\Typora\typora-user-images\image-20241021225457297.png'><img src="C:\Users\新\AppData\Roaming\Typora\typora-user-images\image-20241021225457297.png" alt="image-20241021225457297"></p>
<h3 id="如何解决半包？"><a href="#如何解决半包？" class="headerlink" title="如何解决半包？"></a>如何解决半包？</h3><p>解决半包的核心思路：在消息头中设置请求体的长度，服务端接收时，判断每次消息的长度是否符合预期，不完整就不读，留到下一次接收到消息时再读取。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (buffer == <span class="hljs-literal">null</span> || buffer.length() == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;消息 buffer 为空&quot;</span>);<br>&#125;<br><span class="hljs-keyword">if</span> (buffer.getBytes().length &lt; ProtocolConstant.MESSAGE_HEADER_LENGTH) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;出现了半包问题&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="如何解决粘包？"><a href="#如何解决粘包？" class="headerlink" title="如何解决粘包？"></a>如何解决粘包？</h3><p>每次只读取指定长度的数据，超过长度的留着下一次接收到消息时再读取</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 解决粘包问题，只读指定长度的数据</span><br><span class="hljs-type">byte</span>[] bodyBytes = buffer.getBytes(<span class="hljs-number">17</span>, <span class="hljs-number">17</span> + header.getBodyLength());<br></code></pre></td></tr></table></figure>

<p>自己实现起来还是比较麻烦的，要记录每次接收到的消息位置，维护字节数组缓存。有没有更简单的方式呢？</p>
<h3 id="Vertx解决半包和粘包"><a href="#Vertx解决半包和粘包" class="headerlink" title="Vertx解决半包和粘包"></a>Vertx解决半包和粘包</h3><p>在Vertx框架中，可以使用内置的<code>RecordParser</code>完美解决半包粘包问题，它的作用是：保证下次读取到<code>特定长度</code>的字符</p>
<h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yupi.yurpc.server.tcp;<br><br><span class="hljs-keyword">import</span> com.yupi.yurpc.server.HttpServer;<br><span class="hljs-keyword">import</span> io.vertx.core.Handler;<br><span class="hljs-keyword">import</span> io.vertx.core.Vertx;<br><span class="hljs-keyword">import</span> io.vertx.core.buffer.Buffer;<br><span class="hljs-keyword">import</span> io.vertx.core.net.NetServer;<br><span class="hljs-keyword">import</span> io.vertx.core.parsetools.RecordParser;<br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VertxTcpServer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HttpServer</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doStart</span><span class="hljs-params">(<span class="hljs-type">int</span> port)</span> &#123;<br>        <span class="hljs-comment">// 创建 Vert.x 实例</span><br>        <span class="hljs-type">Vertx</span> <span class="hljs-variable">vertx</span> <span class="hljs-operator">=</span> Vertx.vertx();<br><br>        <span class="hljs-comment">// 创建 TCP 服务器</span><br>        <span class="hljs-type">NetServer</span> <span class="hljs-variable">server</span> <span class="hljs-operator">=</span> vertx.createNetServer();<br><br>        <span class="hljs-comment">// 处理请求</span><br><span class="hljs-comment">//        server.connectHandler(new TcpServerHandler());</span><br>        server.connectHandler(socket -&gt; &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">testMessage</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello, server!Hello, server!Hello, server!Hello, server!&quot;</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">messageLength</span> <span class="hljs-operator">=</span> testMessage.getBytes().length;<br><br>            <span class="hljs-comment">// 构造parser</span><br>            <span class="hljs-type">RecordParser</span> <span class="hljs-variable">parser</span> <span class="hljs-operator">=</span> RecordParser.newFixed(messageLength);<br>            parser.setOutput(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>&lt;Buffer&gt;() &#123;<br><br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">(Buffer buffer)</span> &#123;<br>                    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buffer.getBytes());<br>                    System.out.println(str);<br>                    <span class="hljs-keyword">if</span> (testMessage.equals(str)) &#123;<br>                        System.out.println(<span class="hljs-string">&quot;good&quot;</span>);<br>                    &#125;<br>                &#125;<br>            &#125;);<br><br>            socket.handler(parser);<br>        &#125;);<br><br>        <span class="hljs-comment">// 启动 TCP 服务器并监听指定端口</span><br>        server.listen(port, result -&gt; &#123;<br>            <span class="hljs-keyword">if</span> (result.succeeded()) &#123;<br>                log.info(<span class="hljs-string">&quot;TCP server started on port &quot;</span> + port);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                log.info(<span class="hljs-string">&quot;Failed to start TCP server: &quot;</span> + result.cause());<br>            &#125;<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">VertxTcpServer</span>().doStart(<span class="hljs-number">8888</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述代码的核心是：<code>RecordParser.newFixed(messageLength)</code>，为Parser指定每次读取固定长度的内容</p>
<p>测试发现，这次的输出结果非常整齐，解决了半包和粘包：</p>
<p class='item-img' data-src='C:\Users\新\AppData\Roaming\Typora\typora-user-images\image-20241021232950574.png'><img src="C:\Users\新\AppData\Roaming\Typora\typora-user-images\image-20241021232950574.png" alt="image-20241021232950574"></p>
<h4 id="实际运用"><a href="#实际运用" class="headerlink" title="实际运用"></a>实际运用</h4><p>消息的长度是不固定的，所以要通过调整RecordParser的固定长度（变长）来解决</p>
<p>那我们的思路可以是，将读取完整的消息拆分为2次：</p>
<ul>
<li>先完整读取请求头信息，由于请求头信息长度是固定的，可以使用RecordParser保证每次都完整读取</li>
<li>再根据请求头长度信息更改RecordParser的固定长度，保证完整获取到请求体</li>
</ul>
<p>修改测试的TCP Server代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yupi.yurpc.server.tcp;<br><br><span class="hljs-keyword">import</span> com.yupi.yurpc.protocol.ProtocolConstant;<br><span class="hljs-keyword">import</span> com.yupi.yurpc.server.HttpServer;<br><span class="hljs-keyword">import</span> io.vertx.core.Handler;<br><span class="hljs-keyword">import</span> io.vertx.core.Vertx;<br><span class="hljs-keyword">import</span> io.vertx.core.buffer.Buffer;<br><span class="hljs-keyword">import</span> io.vertx.core.net.NetServer;<br><span class="hljs-keyword">import</span> io.vertx.core.parsetools.RecordParser;<br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VertxTcpServer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HttpServer</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doStart</span><span class="hljs-params">(<span class="hljs-type">int</span> port)</span> &#123;<br>        <span class="hljs-comment">// 创建 Vert.x 实例</span><br>        <span class="hljs-type">Vertx</span> <span class="hljs-variable">vertx</span> <span class="hljs-operator">=</span> Vertx.vertx();<br><br>        <span class="hljs-comment">// 创建 TCP 服务器</span><br>        <span class="hljs-type">NetServer</span> <span class="hljs-variable">server</span> <span class="hljs-operator">=</span> vertx.createNetServer();<br><br>        <span class="hljs-comment">// 处理请求</span><br>        server.connectHandler(socket -&gt; &#123;<br>            <span class="hljs-comment">// 构造 parser</span><br>            <span class="hljs-type">RecordParser</span> <span class="hljs-variable">parser</span> <span class="hljs-operator">=</span> RecordParser.newFixed(<span class="hljs-number">8</span>);<br>            parser.setOutput(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>&lt;Buffer&gt;() &#123;<br>                <span class="hljs-comment">// 初始化</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>                <span class="hljs-comment">// 一次完整的读取（头 + 体）</span><br>                <span class="hljs-type">Buffer</span> <span class="hljs-variable">resultBuffer</span> <span class="hljs-operator">=</span> Buffer.buffer();<br><br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">(Buffer buffer)</span> &#123;<br>                    <span class="hljs-keyword">if</span> (-<span class="hljs-number">1</span> == size) &#123;<br>                        <span class="hljs-comment">// 读取消息体长度</span><br>                        size = buffer.getInt(<span class="hljs-number">4</span>);<br>                        parser.fixedSizeMode(size);<br>                        <span class="hljs-comment">// 写入头信息到结果</span><br>                        resultBuffer.appendBuffer(buffer);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-comment">// 写入体信息到结果</span><br>                        resultBuffer.appendBuffer(buffer);<br>                        System.out.println(resultBuffer.toString());<br>                        <span class="hljs-comment">// 重置一轮</span><br>                        parser.fixedSizeMode(<span class="hljs-number">8</span>);<br>                        size = -<span class="hljs-number">1</span>;<br>                        resultBuffer = Buffer.buffer();<br>                    &#125;<br>                &#125;<br>            &#125;);<br><br>            socket.handler(parser);<br>        &#125;);<br><br>        <span class="hljs-comment">// 启动 TCP 服务器并监听指定端口</span><br>        server.listen(port, result -&gt; &#123;<br>            <span class="hljs-keyword">if</span> (result.succeeded()) &#123;<br>                log.info(<span class="hljs-string">&quot;TCP server started on port &quot;</span> + port);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                log.info(<span class="hljs-string">&quot;Failed to start TCP server: &quot;</span> + result.cause());<br>            &#125;<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">VertxTcpServer</span>().doStart(<span class="hljs-number">8888</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>修改测试TCP Client代码如下：自己构造了一个变长、长度信息不在Buffer最开头（而是有一定偏移量）的消息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yupi.yurpc.server.tcp;<br><br><span class="hljs-keyword">import</span> io.vertx.core.Vertx;<br><span class="hljs-keyword">import</span> io.vertx.core.buffer.Buffer;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VertxTcpClient</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 创建 Vert.x 实例</span><br>        <span class="hljs-type">Vertx</span> <span class="hljs-variable">vertx</span> <span class="hljs-operator">=</span> Vertx.vertx();<br><br>        vertx.createNetClient().connect(<span class="hljs-number">8888</span>, <span class="hljs-string">&quot;localhost&quot;</span>, result -&gt; &#123;<br>            <span class="hljs-keyword">if</span> (result.succeeded()) &#123;<br>                System.out.println(<span class="hljs-string">&quot;Connected to TCP server&quot;</span>);<br>                io.vertx.core.net.<span class="hljs-type">NetSocket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> result.result();<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>                    <span class="hljs-comment">// 发送数据</span><br>                    <span class="hljs-type">Buffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> Buffer.buffer();<br>                    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello, server!Hello, server!Hello, server!Hello, server!&quot;</span>;<br>                    buffer.appendInt(<span class="hljs-number">0</span>);<br>                    buffer.appendInt(str.getBytes().length);<br>                    buffer.appendBytes(str.getBytes());<br>                    socket.write(buffer);<br>                &#125;<br>                <span class="hljs-comment">// 接收响应</span><br>                socket.handler(buffer -&gt; &#123;<br>                    System.out.println(<span class="hljs-string">&quot;Received response from server: &quot;</span> + buffer.toString());<br>                &#125;);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                System.err.println(<span class="hljs-string">&quot;Failed to connect to TCP server&quot;</span>);<br>            &#125;<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">VertxTcpClient</span>().start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>最后测试结果应该是能正常读取消息的，不会出现半包和粘包</p>
<h4 id="封装半包粘包处理器"><a href="#封装半包粘包处理器" class="headerlink" title="封装半包粘包处理器"></a>封装半包粘包处理器</h4><p>解决半包粘包问题还是有一定的代码量的，而且由于ServiceProxy（消费者）和请求Handler（提供者）都需要接收Buffer，所以都需半包粘包问题处理</p>
<p>因此，需要对代码进行封装复用</p>
<p>这里使用设计模式中的<code>装饰着模式</code>,使用RecordParser对原有的Buffer处理器的能力进行增强</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yupi.yurpc.server.tcp;<br><br><span class="hljs-keyword">import</span> com.yupi.yurpc.protocol.ProtocolConstant;<br><span class="hljs-keyword">import</span> io.vertx.core.Handler;<br><span class="hljs-keyword">import</span> io.vertx.core.buffer.Buffer;<br><span class="hljs-keyword">import</span> io.vertx.core.parsetools.RecordParser;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 装饰者模式（使用 recordParser 对原有的 buffer 处理能力进行增强）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TcpBufferHandlerWrapper</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Handler</span>&lt;Buffer&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RecordParser recordParser;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TcpBufferHandlerWrapper</span><span class="hljs-params">(Handler&lt;Buffer&gt; bufferHandler)</span> &#123;<br>        recordParser = initRecordParser(bufferHandler);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">(Buffer buffer)</span> &#123;<br>        recordParser.handle(buffer);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> RecordParser <span class="hljs-title function_">initRecordParser</span><span class="hljs-params">(Handler&lt;Buffer&gt; bufferHandler)</span> &#123;<br>        <span class="hljs-comment">// 构造 parser</span><br>        <span class="hljs-type">RecordParser</span> <span class="hljs-variable">parser</span> <span class="hljs-operator">=</span> RecordParser.newFixed(ProtocolConstant.MESSAGE_HEADER_LENGTH);<br><br>        parser.setOutput(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>&lt;Buffer&gt;() &#123;<br>            <span class="hljs-comment">// 初始化</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>            <span class="hljs-comment">// 一次完整的读取（头 + 体）</span><br>            <span class="hljs-type">Buffer</span> <span class="hljs-variable">resultBuffer</span> <span class="hljs-operator">=</span> Buffer.buffer();<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">(Buffer buffer)</span> &#123;<br>                <span class="hljs-keyword">if</span> (-<span class="hljs-number">1</span> == size) &#123;<br>                    <span class="hljs-comment">// 读取消息体长度</span><br>                    size = buffer.getInt(<span class="hljs-number">13</span>);<br>                    parser.fixedSizeMode(size);<br>                    <span class="hljs-comment">// 写入头信息到结果</span><br>                    resultBuffer.appendBuffer(buffer);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 写入体信息到结果</span><br>                    resultBuffer.appendBuffer(buffer);<br>                    <span class="hljs-comment">// 已拼接为完整 Buffer，执行处理</span><br>                    bufferHandler.handle(resultBuffer);<br>                    <span class="hljs-comment">// 重置一轮</span><br>                    parser.fixedSizeMode(ProtocolConstant.MESSAGE_HEADER_LENGTH);<br>                    size = -<span class="hljs-number">1</span>;<br>                    resultBuffer = Buffer.buffer();<br>                &#125;<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-keyword">return</span> parser;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="5-扩展"><a href="#5-扩展" class="headerlink" title="5.扩展"></a>5.扩展</h2><ul>
<li>自己定义一个占用空间更少的RPC协议的消息结构</li>
</ul>
<p>参考思路：序列化方式字段目前占了8 bit，但是其实总共就几种序列化方式，能否只占用4bit,其它字段也可以按照这种思路进行思考</p>
<h2 id="6-最后"><a href="#6-最后" class="headerlink" title="6.最后"></a>6.最后</h2><p>为什么tcpServer不提供一个server接口，或者和httpServer公用接口？</p>
<p>替换这俩个服务器（协议实现）涉及的改动点非常多，比如RPC协议，请求处理器等，不是直接通过配置就替换的，而且RPC框架一般也不需要替换底层协议，只使用TCP会更好</p>
<h1 id="七、负载均衡"><a href="#七、负载均衡" class="headerlink" title="七、负载均衡"></a>七、负载均衡</h1><h2 id="1-需求分析-6"><a href="#1-需求分析-6" class="headerlink" title="1.需求分析"></a>1.需求分析</h2><p>目前的RPC框架已经可以从注册中心获取服务提供者的注册信息了，同一个服务可能会有多个服务提供者，但是目前我们消费者始终读取了第一个服务提供者节点发起调用，不仅会增大单个节点的压力，且没有利用好其它节点的资源。</p>
<p>我们完全可以从服务提供节点中选择一个服务提供者发起请求，而不是每次都请求同一个服务提供者，这就是<code>负载均衡</code></p>
<h2 id="2-负载均衡"><a href="#2-负载均衡" class="headerlink" title="2.负载均衡"></a>2.负载均衡</h2><p>常用的负载均衡实现的技术有Nginx（七层负载均衡）、LVS（四层负载均衡）等</p>
<h2 id="3-常见的负载均衡算法"><a href="#3-常见的负载均衡算法" class="headerlink" title="3.常见的负载均衡算法"></a>3.常见的负载均衡算法</h2><ul>
<li>轮询（Round Robin）：按照循环的顺序将请求分配给每个服务器，适用于服务器性能相近的情况</li>
<li>随机（Random）：随机选择一个服务器来处理请求，适用于性能相近且负载均匀的情况</li>
<li>加权轮询（Weighted Round Robin）：根据服务器的性能或权重分配请求，性能更好的服务器会获得更多的请求，适用于性能不均的情况</li>
<li>加权随机（Weighted Random）：根据服务器的权重随机选择一个服务器处理请求，适用于性能不均的情况</li>
<li>最小连接数（Least Connections）选择当前连接数最少的服务器来处理请求，适用于长连接场景</li>
<li>IP Hash：根据客户端IP地址的哈希值选择服务器处理请求，确保同一客户端的请求始终分配到同一台服务器上，适用于需要保持会话一致性的场景，当然也可以根据请求中的其它参数进行hash处理，比如根据请求接口的地址路由到不同的服务器节点</li>
</ul>
<h3 id="一致性Hash"><a href="#一致性Hash" class="headerlink" title="一致性Hash"></a>一致性Hash</h3><p>一致性（Consistent Hashing）是一种经典的哈希算法，用于将请求分配到多个节点或服务器上，所以非常适合用于负载均衡</p>
<p>其核心思想是将整个Hash值空间划分成一个环状结构，每个节点或服务器在的环上占据一个位置，每个请求根据其哈希值映射到环上的一个点，然后顺时针寻找第一个大于或等于该哈希值的节点，将请求路由到该节点上</p>
<p>一致性哈希环结构如图：</p>
<p class='item-img' data-src='C:\Users\新\AppData\Roaming\Typora\typora-user-images\image-20241026002058595.png'><img src="C:\Users\新\AppData\Roaming\Typora\typora-user-images\image-20241026002058595.png" alt="image-20241026002058595"></p>
<p>哈希一致性解决了：</p>
<ul>
<li>节点下线：当某个节点下线时，其负载会被平均分摊到其它节点上，而不会影响整个系统的稳定性，因为只有部分请求会受到影响</li>
</ul>
<p>如下图：服务器C下线后，请求A会交给服务器A来处理（顺时针寻找第一个大于或等于该哈希值的节点），而服务器B接收到的请求不变</p>
<p>如果是轮询算法，只要节点数变了，很有可能大多数服务器处理的请求都要发生变化，对系统影响巨大</p>
<p class='item-img' data-src='C:\Users\新\AppData\Roaming\Typora\typora-user-images\image-20241026002444174.png'><img src="C:\Users\新\AppData\Roaming\Typora\typora-user-images\image-20241026002444174.png" alt="image-20241026002444174"></p>
<ul>
<li>倾斜问题：通过虚拟节点的引入，将每个物理节点映射到多个虚拟节点上，使得节点在哈希环上的<code>分布更加均匀</code>，减少节点间的负载差异</li>
</ul>
<p>例子：节点很少的情况下，环的情况可能如下：</p>
<p class='item-img' data-src='C:\Users\新\AppData\Roaming\Typora\typora-user-images\image-20241026002913070.png'><img src="C:\Users\新\AppData\Roaming\Typora\typora-user-images\image-20241026002913070.png" alt="image-20241026002913070"></p>
<p>这样会导致绝大多数的请求都会发给服务器C，而服务器A的“领地”非常少，几乎不会有请求</p>
<p>引入虚拟节点后。环变为：</p>
<p class='item-img' data-src='C:\Users\新\AppData\Roaming\Typora\typora-user-images\image-20241026003035039.png'><img src="C:\Users\新\AppData\Roaming\Typora\typora-user-images\image-20241026003035039.png" alt="image-20241026003035039"></p>
<p>这样一来，每个服务器接收到的请求就会更平均</p>
<h2 id="4-开发实现"><a href="#4-开发实现" class="headerlink" title="4.开发实现"></a>4.开发实现</h2><h3 id="多种负载均衡器实现"><a href="#多种负载均衡器实现" class="headerlink" title="多种负载均衡器实现"></a>多种负载均衡器实现</h3><p>新建loadbalancer包，将所有负载均衡相关的代码放到该包下</p>
<ol>
<li><p>先编写负载均衡器通用接口，提供一个选择服务方法，接收请求参数和可用服务列表，可以根据这些信息进行选择</p>
</li>
<li><p>轮询负载均衡器<br>使用JUC包的AtomicInteger实现原子计数器，防止并发冲突问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yupi.yurpc.loadbalancer;<br><br><span class="hljs-keyword">import</span> com.yupi.yurpc.model.ServiceMetaInfo;<br><br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicInteger;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 轮询负载均衡器</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> &lt;a href=&quot;https://github.com/liyupi&quot;&gt;程序员鱼皮&lt;/a&gt;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@learn</span> &lt;a href=&quot;https://codefather.cn&quot;&gt;鱼皮的编程宝典&lt;/a&gt;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@from</span> &lt;a href=&quot;https://yupi.icu&quot;&gt;编程导航学习圈&lt;/a&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RoundRobinLoadBalancer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">LoadBalancer</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 当前轮询的下标</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">currentIndex</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> ServiceMetaInfo <span class="hljs-title function_">select</span><span class="hljs-params">(Map&lt;String, Object&gt; requestParams, List&lt;ServiceMetaInfo&gt; serviceMetaInfoList)</span> &#123;<br>        <span class="hljs-keyword">if</span> (serviceMetaInfoList.isEmpty()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-comment">// 只有一个服务，无需轮询</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> serviceMetaInfoList.size();<br>        <span class="hljs-keyword">if</span> (size == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> serviceMetaInfoList.get(<span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-comment">// 取模算法轮询</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> currentIndex.getAndIncrement() % size;<br>        <span class="hljs-keyword">return</span> serviceMetaInfoList.get(index);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
</li>
<li><p>随机负载均衡器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yupi.yurpc.loadbalancer;<br><br><span class="hljs-keyword">import</span> com.yupi.yurpc.model.ServiceMetaInfo;<br><br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> java.util.Random;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 随机负载均衡器</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> &lt;a href=&quot;https://github.com/liyupi&quot;&gt;程序员鱼皮&lt;/a&gt;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@learn</span> &lt;a href=&quot;https://codefather.cn&quot;&gt;鱼皮的编程宝典&lt;/a&gt;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@from</span> &lt;a href=&quot;https://yupi.icu&quot;&gt;编程导航学习圈&lt;/a&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RandomLoadBalancer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">LoadBalancer</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> ServiceMetaInfo <span class="hljs-title function_">select</span><span class="hljs-params">(Map&lt;String, Object&gt; requestParams, List&lt;ServiceMetaInfo&gt; serviceMetaInfoList)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> serviceMetaInfoList.size();<br>        <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-comment">// 只有 1 个服务，不用随机</span><br>        <span class="hljs-keyword">if</span> (size == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> serviceMetaInfoList.get(<span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> serviceMetaInfoList.get(random.nextInt(size));<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
</li>
<li><p>实现一致性Hash负载均衡器<br>可以使用TreeMap实现一致性Hash环，该数据结构提供了ceilingEntry和firstEntry两个方法，便于获取符合算法要求的节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yupi.yurpc.loadbalancer;<br><br><span class="hljs-keyword">import</span> com.yupi.yurpc.model.ServiceMetaInfo;<br><br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> java.util.TreeMap;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 一致性哈希负载均衡器</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> &lt;a href=&quot;https://github.com/liyupi&quot;&gt;程序员鱼皮&lt;/a&gt;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@learn</span> &lt;a href=&quot;https://codefather.cn&quot;&gt;鱼皮的编程宝典&lt;/a&gt;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@from</span> &lt;a href=&quot;https://yupi.icu&quot;&gt;编程导航学习圈&lt;/a&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConsistentHashLoadBalancer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">LoadBalancer</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 一致性 Hash 环，存放虚拟节点</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> TreeMap&lt;Integer, ServiceMetaInfo&gt; virtualNodes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 虚拟节点数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">VIRTUAL_NODE_NUM</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> ServiceMetaInfo <span class="hljs-title function_">select</span><span class="hljs-params">(Map&lt;String, Object&gt; requestParams, List&lt;ServiceMetaInfo&gt; serviceMetaInfoList)</span> &#123;<br>        <span class="hljs-keyword">if</span> (serviceMetaInfoList.isEmpty()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 构建虚拟节点环</span><br>        <span class="hljs-keyword">for</span> (ServiceMetaInfo serviceMetaInfo : serviceMetaInfoList) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; VIRTUAL_NODE_NUM; i++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> getHash(serviceMetaInfo.getServiceAddress() + <span class="hljs-string">&quot;#&quot;</span> + i);<br>                virtualNodes.put(hash, serviceMetaInfo);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 获取调用请求的 hash 值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> getHash(requestParams);<br><br>        <span class="hljs-comment">// 选择最接近且大于等于调用请求 hash 值的虚拟节点</span><br>        Map.Entry&lt;Integer, ServiceMetaInfo&gt; entry = virtualNodes.ceilingEntry(hash);<br>        <span class="hljs-keyword">if</span> (entry == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 如果没有大于等于调用请求 hash 值的虚拟节点，则返回环首部的节点</span><br>            entry = virtualNodes.firstEntry();<br>        &#125;<br>        <span class="hljs-keyword">return</span> entry.getValue();<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Hash 算法，可自行实现</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getHash</span><span class="hljs-params">(Object key)</span> &#123;<br>        <span class="hljs-keyword">return</span> key.hashCode();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>上诉代码中需要注意两点：</p>
<ul>
<li>根据requestParams对象计算对象Hash值，这里只是简单的调用了hashCode方法，实际可以根据需求自定义实现</li>
<li>每次调用负载均衡时，都会重新构造Hash环，这是为了能够即时处理节点的变化</li>
</ul>
</li>
</ol>
<h3 id="支持配置和扩展负载均衡器"><a href="#支持配置和扩展负载均衡器" class="headerlink" title="支持配置和扩展负载均衡器"></a>支持配置和扩展负载均衡器</h3><p>需求是让开发者能够填写配置来指定使用的负载均衡器，并且支持自定义负载均衡器，让框架更加易用和利于扩展</p>
<ol>
<li>负载均衡器常量</li>
<li>使用工厂模式，支持根据key从SPI获取负载均衡器对象实例</li>
<li>应用负载均衡器</li>
</ol>
<p>在实现的几种负载均衡器的方法参数中都传入一个<code>requestParams HashMap</code>，并且将请求方法名作为参数放到了Map中，如果使用的是一致性Hash算法，那么会根据requestParams计算hash值，调用相同的方法的请求hash值肯定相同，因此会请求到同一个服务器上</p>
<h2 id="5-测试"><a href="#5-测试" class="headerlink" title="5.测试"></a>5.测试</h2><p>。。。。</p>
<h2 id="6-扩展"><a href="#6-扩展" class="headerlink" title="6.扩展"></a>6.扩展</h2><ul>
<li><p>实现更多不同算法的负载均衡器<br>参考思路：比如最少活跃负载均衡器，选择当前正在处理请求的数量最少的服务提供者</p>
</li>
<li><p>自定义一致性Hash算法中的hash算法</p>
<p>参考思路：比如根据请求客户端的ip地址来计算hash值，保证同ip的请求发送给相同的服务器</p>
</li>
</ul>
<h1 id="八、重试机制"><a href="#八、重试机制" class="headerlink" title="八、重试机制"></a>八、重试机制</h1><h2 id="1-需求分析-7"><a href="#1-需求分析-7" class="headerlink" title="1.需求分析"></a>1.需求分析</h2><p>目前，如果使用rpc框架的服务消费者调用接口失败，就会直接报错</p>
<p>调用接口失败的原因有很多，有时可能是服务提供者返回了错误，但有时可能只是网络不稳定或服务提供者重启等临时性问题，这种情况下，我们可能更希望服务消费者拥有自动重试的能力，提高系统的可用性</p>
<h2 id="2-设计方案-5"><a href="#2-设计方案-5" class="headerlink" title="2.设计方案"></a>2.设计方案</h2><h3 id="重试机制"><a href="#重试机制" class="headerlink" title="重试机制"></a>重试机制</h3><p>重试机制的核心是：<code>重试策略</code>，一般来说，包含以下几个考虑点：</p>
<ol>
<li>什么时候、条件下重试？</li>
<li>重试时间（确定下一次的重试时间）</li>
<li>什么时候、条件下停重试？</li>
<li>重试后要做什么？</li>
</ol>
<h4 id="重试条件"><a href="#重试条件" class="headerlink" title="重试条件"></a>重试条件</h4><p>当由于网络异常情况发生时，触发重试</p>
<h4 id="重试时间"><a href="#重试时间" class="headerlink" title="重试时间"></a>重试时间</h4><p>主流的重试时间的算法：</p>
<ul>
<li>固定重试间隔（Fixed Retry Interval）：每次重试时间间隔使用固定的时间</li>
<li>指数退避重试（Exponential Backoff Retry）：每次失败后，重试的时间间隔会以指数级增加，以避免请求过于密集</li>
<li>随机延迟重试（Radom Delay Retry）：在每次重试之间使用随机的时间间隔，避免请求的同时发生</li>
<li>可变延迟重试（Variable Delay Retry）：这种策略更“高级”了，根据的先前重试的成功或失败情况，动态调整下一次重试的延迟时间，比如，根据前一次的响应时间调整下一次重试的等待时间</li>
</ul>
<p>值得一提的是，以上的策略是可以组合使用的，一定要根据具体的情况和需求灵活调整，比如可以先使用指数退避重试策略，如果连续多次重试失败，则切换到固定重试间隔策略</p>
<h4 id="停止重试"><a href="#停止重试" class="headerlink" title="停止重试"></a>停止重试</h4><p>重试的次数是有限制的，主流的停止重试策略有：</p>
<ul>
<li>最大尝试次数：一般重试达到最大次数时不再重试</li>
<li>超时停止：重试达到最大时间的时候，停止重试</li>
</ul>
<h4 id="重试工作"><a href="#重试工作" class="headerlink" title="重试工作"></a>重试工作</h4><p>重试一般就是重复执行原本的操作，比如发送请求失败了，那就再发一次请求。</p>
<p>需要注意的是，当重试次数超过上限时，往往还要进行其它操作，比如：</p>
<ul>
<li>通知告警：让开发者人工介入</li>
<li>降级容错：改为调用其它接口，或者执行其它操作</li>
</ul>
<h3 id="重试方案设计"><a href="#重试方案设计" class="headerlink" title="重试方案设计"></a>重试方案设计</h3><p>我们可以将<code>VertxTcpClient.doRequest</code>封装为一个可以重试的任务，如果请求失败（重试条件），系统就会自动按照重试策略再次发送请求，不用开发者关心</p>
<p>对于重试算法，直接选择主流的算法即可，Java中可以使用Guava-Retrying库轻松实现多种不同的重试算法</p>
<p>和序列化器，注册中心、负载均衡一样，重试策略本身也可以使用SPI+工厂的方式、允许开发者动态配置和扩展自己的重试策略</p>
<p>最后，如果重超过一定次数，就停止重试且抛出异常，之后还会有重试失败后的另一种选择——容错机制</p>
<h2 id="3-开发实现-4"><a href="#3-开发实现-4" class="headerlink" title="3.开发实现"></a>3.开发实现</h2><h3 id="多种重试策略的实现"><a href="#多种重试策略的实现" class="headerlink" title="多种重试策略的实现"></a>多种重试策略的实现</h3><p>新建<code>fault.retry</code>包，将所有重试的代码放入该包下</p>
<ol>
<li><p>先编写重试策略的通用接口，提供一个重试方法，接收一个具体的任务参数，可以使用Callable类代表一个任务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yupi.yurpc.fault.retry;<br><br><span class="hljs-keyword">import</span> com.yupi.yurpc.model.RpcResponse;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.Callable;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 重试策略</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> &lt;a href=&quot;https://github.com/liyupi&quot;&gt;程序员鱼皮&lt;/a&gt;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@learn</span> &lt;a href=&quot;https://codefather.cn&quot;&gt;鱼皮的编程宝典&lt;/a&gt;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@from</span> &lt;a href=&quot;https://yupi.icu&quot;&gt;编程导航学习圈&lt;/a&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">RetryStrategy</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 重试</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> callable</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    RpcResponse <span class="hljs-title function_">doRetry</span><span class="hljs-params">(Callable&lt;RpcResponse&gt; callable)</span> <span class="hljs-keyword">throws</span> Exception;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>引入Guava-Retrying重试库</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://github.com/rholder/guava-retrying --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.rholder<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>guava-retrying<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>不重试策略的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yupi.yurpc.fault.retry;<br><br><span class="hljs-keyword">import</span> com.yupi.yurpc.model.RpcResponse;<br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.Callable;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 不重试 - 重试策略</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> &lt;a href=&quot;https://github.com/liyupi&quot;&gt;程序员鱼皮&lt;/a&gt;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@learn</span> &lt;a href=&quot;https://codefather.cn&quot;&gt;鱼皮的编程宝典&lt;/a&gt;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@from</span> &lt;a href=&quot;https://yupi.icu&quot;&gt;编程导航学习圈&lt;/a&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NoRetryStrategy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RetryStrategy</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 重试</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> callable</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> RpcResponse <span class="hljs-title function_">doRetry</span><span class="hljs-params">(Callable&lt;RpcResponse&gt; callable)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">return</span> callable.call();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>固定重试间隔策略实现<br>使用<code>Guava-Retrying</code>提供的<code>RetryBuilder</code>能够很方便的指定重试条件，重试等待策略，重试停止策略，重试工作等</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yupi.yurpc.fault.retry;<br><br><span class="hljs-keyword">import</span> com.github.rholder.retry.*;<br><span class="hljs-keyword">import</span> com.yupi.yurpc.model.RpcResponse;<br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.Callable;<br><span class="hljs-keyword">import</span> java.util.concurrent.ExecutionException;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 固定时间间隔 - 重试策略</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> &lt;a href=&quot;https://github.com/liyupi&quot;&gt;程序员鱼皮&lt;/a&gt;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@learn</span> &lt;a href=&quot;https://codefather.cn&quot;&gt;鱼皮的编程宝典&lt;/a&gt;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@from</span> &lt;a href=&quot;https://yupi.icu&quot;&gt;编程导航学习圈&lt;/a&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FixedIntervalRetryStrategy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RetryStrategy</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 重试</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> callable</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> ExecutionException</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> RetryException</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> RpcResponse <span class="hljs-title function_">doRetry</span><span class="hljs-params">(Callable&lt;RpcResponse&gt; callable)</span> <span class="hljs-keyword">throws</span> ExecutionException, RetryException &#123;<br>        Retryer&lt;RpcResponse&gt; retryer = RetryerBuilder.&lt;RpcResponse&gt;newBuilder()<br>                .retryIfExceptionOfType(Exception.class)<br>                .withWaitStrategy(WaitStrategies.fixedWait(<span class="hljs-number">3L</span>, TimeUnit.SECONDS))<br>                .withStopStrategy(StopStrategies.stopAfterAttempt(<span class="hljs-number">3</span>))<br>                .withRetryListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RetryListener</span>() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">public</span> &lt;V&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">onRetry</span><span class="hljs-params">(Attempt&lt;V&gt; attempt)</span> &#123;<br>                        log.info(<span class="hljs-string">&quot;重试次数 &#123;&#125;&quot;</span>, attempt.getAttemptNumber());<br>                    &#125;<br>                &#125;)<br>                .build();<br>        <span class="hljs-keyword">return</span> retryer.call(callable);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>上诉代码中，重试策略如下：</p>
<ul>
<li>重试条件：使用<code>retryIfExceptionOfType</code>方法指定当出现Exception异常时重试</li>
<li>重试等待策略：使用<code>withWaitStrategy</code>方法指定策略，选择<code>fixedWait</code>固定时间间隔策略</li>
<li>重试停止策略：使用<code>withStopStrategy</code>方法指定策略，选择<code>stopAfterAttempt</code>超过最大重试次数停止</li>
<li>重试工作：使用<code>withRetryListener</code>监听重试，每次重试时，除了再次执行任务外，还能能够打印当前的重试次数</li>
</ul>
</li>
</ol>
<h3 id="支持配置和扩展重试策略"><a href="#支持配置和扩展重试策略" class="headerlink" title="支持配置和扩展重试策略"></a>支持配置和扩展重试策略</h3><p>框架应该支持多种不同的重试策略，像序列化器、注册中心、负载均衡器一样，现在要实现的是通过填写配置来指定使用的重试策略，并且支持自定义策略</p>
<ol>
<li>重试策略常量</li>
<li>使用工厂模式，支持根据key从SPI获取重试策略对象实例</li>
<li>在<code>MATE-IN</code>的<code>rpc/system</code>目录下编写重试策略接口的SPI配置文件，文件名称为<code>com.yupi.yurpc.fault.retry.RetryStrategy</code></li>
<li>为RpcConfig全局配置新增重试策略的配置</li>
</ol>
<h3 id="应用重试功能"><a href="#应用重试功能" class="headerlink" title="应用重试功能"></a>应用重试功能</h3><p>修改ServiceProxy的代码，从工厂中获取重试器，并将请求代码封装为一个Callable接口，作为重试器的参数，调用重试器即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用重试机制</span><br><span class="hljs-type">RetryStrategy</span> <span class="hljs-variable">retryStrategy</span> <span class="hljs-operator">=</span> RetryStrategyFactory.getInstance(rpcConfig.getRetryStrategy());<br><span class="hljs-type">RpcResponse</span> <span class="hljs-variable">rpcResponse</span> <span class="hljs-operator">=</span> retryStrategy.doRetry(() -&gt;<br>        VertxTcpClient.doRequest(rpcRequest, selectedServiceMetaInfo)<br>);<br></code></pre></td></tr></table></figure>

<p>上述代码使用Lambda表达式将<code>VertxTcpClient.doRequest</code>封装为了一个匿名函数，简化了代码</p>
<p>修改后的完整代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 服务代理（JDK 动态代理）</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> &lt;a href=&quot;https://github.com/liyupi&quot;&gt;程序员鱼皮&lt;/a&gt;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@learn</span> &lt;a href=&quot;https://codefather.cn&quot;&gt;编程宝典&lt;/a&gt;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@from</span> &lt;a href=&quot;https://yupi.icu&quot;&gt;编程导航知识星球&lt;/a&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServiceProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 调用代理</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Throwable</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-comment">// 指定序列化器</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Serializer</span> <span class="hljs-variable">serializer</span> <span class="hljs-operator">=</span> SerializerFactory.getInstance(RpcApplication.getRpcConfig().getSerializer());<br><br>        <span class="hljs-comment">// 构造请求</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">serviceName</span> <span class="hljs-operator">=</span> method.getDeclaringClass().getName();<br>        <span class="hljs-type">RpcRequest</span> <span class="hljs-variable">rpcRequest</span> <span class="hljs-operator">=</span> RpcRequest.builder()<br>                .serviceName(serviceName)<br>                .methodName(method.getName())<br>                .parameterTypes(method.getParameterTypes())<br>                .args(args)<br>                .build();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 从注册中心获取服务提供者请求地址</span><br>            <span class="hljs-type">RpcConfig</span> <span class="hljs-variable">rpcConfig</span> <span class="hljs-operator">=</span> RpcApplication.getRpcConfig();<br>            <span class="hljs-type">Registry</span> <span class="hljs-variable">registry</span> <span class="hljs-operator">=</span> RegistryFactory.getInstance(rpcConfig.getRegistryConfig().getRegistry());<br>            <span class="hljs-type">ServiceMetaInfo</span> <span class="hljs-variable">serviceMetaInfo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServiceMetaInfo</span>();<br>            serviceMetaInfo.setServiceName(serviceName);<br>            serviceMetaInfo.setServiceVersion(RpcConstant.DEFAULT_SERVICE_VERSION);<br>            List&lt;ServiceMetaInfo&gt; serviceMetaInfoList = registry.serviceDiscovery(serviceMetaInfo.getServiceKey());<br>            <span class="hljs-keyword">if</span> (CollUtil.isEmpty(serviceMetaInfoList)) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;暂无服务地址&quot;</span>);<br>            &#125;<br>            <br>            <span class="hljs-comment">// 负载均衡</span><br>            <span class="hljs-type">LoadBalancer</span> <span class="hljs-variable">loadBalancer</span> <span class="hljs-operator">=</span> LoadBalancerFactory.getInstance(rpcConfig.getLoadBalancer());<br>            <span class="hljs-comment">// 将调用方法名（请求路径）作为负载均衡参数</span><br>            Map&lt;String, Object&gt; requestParams = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>            requestParams.put(<span class="hljs-string">&quot;methodName&quot;</span>, rpcRequest.getMethodName());<br>            <span class="hljs-type">ServiceMetaInfo</span> <span class="hljs-variable">selectedServiceMetaInfo</span> <span class="hljs-operator">=</span> loadBalancer.select(requestParams, serviceMetaInfoList);<br>            <br>            <span class="hljs-comment">// rpc 请求</span><br>            <span class="hljs-comment">// 使用重试机制</span><br>            <span class="hljs-type">RetryStrategy</span> <span class="hljs-variable">retryStrategy</span> <span class="hljs-operator">=</span> RetryStrategyFactory.getInstance(rpcConfig.getRetryStrategy());<br>            <span class="hljs-type">RpcResponse</span> <span class="hljs-variable">rpcResponse</span> <span class="hljs-operator">=</span> retryStrategy.doRetry(() -&gt;<br>                    VertxTcpClient.doRequest(rpcRequest, selectedServiceMetaInfo)<br>            );            <br>            <span class="hljs-keyword">return</span> rpcResponse.getData();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;调用失败&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="4-测试"><a href="#4-测试" class="headerlink" title="4.测试"></a>4.测试</h2><p>。。。。</p>
<h2 id="5-扩展-1"><a href="#5-扩展-1" class="headerlink" title="5.扩展"></a>5.扩展</h2><ol>
<li>新增更多不同类型的重试器<br>参考思路：比如指数退避算法的重试器</li>
</ol>
<h1 id="九、容错机制"><a href="#九、容错机制" class="headerlink" title="九、容错机制"></a>九、容错机制</h1><h2 id="1-需求分析-8"><a href="#1-需求分析-8" class="headerlink" title="1.需求分析"></a>1.需求分析</h2><p>若是重试超过了一定次数仍然失败，我们该如何处理？</p>
<p>或者说当调用出现失败时，一定要重试吗？有没有其它策略？</p>
<p>这个时候就需要另一种机制——容错机制</p>
<h2 id="2-设计方案-6"><a href="#2-设计方案-6" class="headerlink" title="2.设计方案"></a>2.设计方案</h2><h3 id="容错机制"><a href="#容错机制" class="headerlink" title="容错机制"></a>容错机制</h3><p>是指在系统运行出现异常情况时，可以通过一定的策略保证系统仍然稳定运行，从而提高系统的可靠性和健壮性</p>
<p>在分布式系统中，容错机制尤为重要，因为分布式系统中的各个组件都可能存在网络故障、节点故障等各种异常情况，要顾全大局，尽可能消除偶发&#x2F;单点故障对系统带来的整体影响</p>
<p>例如：将分布式系统类比为一家公司，如果公司某个优秀员工请假了，需要触发“容错机制”让一个普通员工顶上，这本质上是容错机制的一种<code>降级</code>策略</p>
<p>容错机制一般都是在系统出现错误时才触发的，我们需要学习的是<code>容错策略</code>和<code>容错实现</code>方式</p>
<h4 id="容错策略"><a href="#容错策略" class="headerlink" title="容错策略"></a>容错策略</h4><p>容错策略有很多种，常用的容错策略主要是以下几个：</p>
<ol>
<li>Fail-Over故障转移：一次调用失败后，切换其它节点再次进行调用，也算是一种重试</li>
<li>Fail-Back失败自动恢复：系统的某个功能出现调用失败或错误时，通过其它方法，恢复该功能的正常，可以理解为降级、比如重试、调用其它服务等</li>
<li>Fail-Safe静默处理：系统出现部分非重要功能的异常时，直接忽略掉，不错任何处理，就当没有发生过</li>
<li>Fail-Fast快速失败：系统出现调用错误时，立即报错，交给外层调用方处理</li>
</ol>
<h4 id="容错实现方式"><a href="#容错实现方式" class="headerlink" title="容错实现方式"></a>容错实现方式</h4><p>容错是一个非常宽泛的概念，除了上面几种策略外，很多技术都可以起到容错的作用</p>
<ol>
<li>重试：重试本质上也是一种容错的降级策略，系统出错之后再调用一次</li>
<li>限流：当系统压力过大，已经出现部分错误时，通过限制执行操作（接收请求）的频率或数量，对系统进行保护</li>
<li>降级：系统出现错误后，改为执行其它更稳定可用的操作，也可以叫“兜底”或“有损服务”，这种方式的本质是：即使牺牲一定的服务质量，也要保证系统的部分功能可用，保证基本的需求得到满足</li>
<li>熔断：系统出现异常或错误时，暂时中断对该服务的请求，而是执行其它操作，以免连锁故障</li>
<li>超时控制：如果请求或操作长时间没有处理完成，就进行中断，防止阻塞和资源占用</li>
</ol>
<p>在实际项目中，根据对系统可靠性的需求，通常结合多种策略或方法实现容错机制</p>
<h3 id="容错方案设计"><a href="#容错方案设计" class="headerlink" title="容错方案设计"></a>容错方案设计</h3><p>之前在系统中增加了重试机制，算是实现了一部分容错能力，此处引入2种容错机制：</p>
<ol>
<li>先容错再重试<br>当系统发生异常时，首先会触发容错机制，比如记录日志，进行警告等，然后可以选择是否进行重试，这种方案其实是把重试当作容错机制的一种可选方案</li>
<li>先重试再容错<br>发生错误后，首先尝试重试操作，如果重试多次仍然失败，则触发容错机制，比如记录日志、进行警告等</li>
</ol>
<p>这两种方式其实可以结合使用：</p>
<p>系统发生错误时，先通过重试操作解决一些临时性的异常，比如网络波动，服务端临时不可用等，如果重试多次后仍然失败，说明可能存在更严重的问题，这时可以触发其它的容错策略，比如调用降级服务、熔断、限流、快速失败等，来减少异常的影响，保证系统的稳定性和可靠性</p>
<p>例子：</p>
<ol>
<li>系统调用服务A出现网络错误，使用容错策略-重试</li>
<li>重试3次失败后，使用其它容错策略-降级</li>
<li>系统改为调用不依赖网络的服务B，完成操作</li>
</ol>
<h2 id="3-开发实现-5"><a href="#3-开发实现-5" class="headerlink" title="3.开发实现"></a>3.开发实现</h2><h3 id="多种容错策略的实现"><a href="#多种容错策略的实现" class="headerlink" title="多种容错策略的实现"></a>多种容错策略的实现</h3><p>实现2种基本的容错策略：<code>Fail-Fast快速失败</code>、<code>Fail-Safe静默处理</code></p>
<ol>
<li><p>先编写容错策略通用接口，提供一个容错方法，使用Map类型的参数接收上下文信息（可用于灵活的传递容错处理需要用到的数据），并且接收一个具体的异常类参数<br>由于容错是应用到发送请求操作的，所以容错方法的返回值是RpcResponse(响应)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yupi.yurpc.fault.tolerant;<br><br><span class="hljs-keyword">import</span> com.yupi.yurpc.model.RpcResponse;<br><br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 容错策略</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> &lt;a href=&quot;https://github.com/liyupi&quot;&gt;程序员鱼皮&lt;/a&gt;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@learn</span> &lt;a href=&quot;https://codefather.cn&quot;&gt;鱼皮的编程宝典&lt;/a&gt;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@from</span> &lt;a href=&quot;https://yupi.icu&quot;&gt;编程导航学习圈&lt;/a&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">TolerantStrategy</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 容错</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> context 上下文，用于传递数据</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> e       异常</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    RpcResponse <span class="hljs-title function_">doTolerant</span><span class="hljs-params">(Map&lt;String, Object&gt; context, Exception e)</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>快速失败容错策略实现<br>遇到异常后，将异常再次抛出，交给外层处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yupi.yurpc.fault.tolerant;<br><br><span class="hljs-keyword">import</span> com.yupi.yurpc.model.RpcResponse;<br><br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 快速失败 - 容错策略（立刻通知外层调用方）</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> &lt;a href=&quot;https://github.com/liyupi&quot;&gt;程序员鱼皮&lt;/a&gt;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@learn</span> &lt;a href=&quot;https://codefather.cn&quot;&gt;鱼皮的编程宝典&lt;/a&gt;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@from</span> &lt;a href=&quot;https://yupi.icu&quot;&gt;编程导航学习圈&lt;/a&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FailFastTolerantStrategy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">TolerantStrategy</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> RpcResponse <span class="hljs-title function_">doTolerant</span><span class="hljs-params">(Map&lt;String, Object&gt; context, Exception e)</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;服务报错&quot;</span>, e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>静默处理容错策略的实现<br>遇到异常后，记录一条日志，然后正常返回一个响应对象，就好像没有出现过报错</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yupi.yurpc.fault.tolerant;<br><br><span class="hljs-keyword">import</span> com.yupi.yurpc.model.RpcResponse;<br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 静默处理异常 - 容错策略</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> &lt;a href=&quot;https://github.com/liyupi&quot;&gt;程序员鱼皮&lt;/a&gt;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@learn</span> &lt;a href=&quot;https://codefather.cn&quot;&gt;鱼皮的编程宝典&lt;/a&gt;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@from</span> &lt;a href=&quot;https://yupi.icu&quot;&gt;编程导航学习圈&lt;/a&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FailSafeTolerantStrategy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">TolerantStrategy</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> RpcResponse <span class="hljs-title function_">doTolerant</span><span class="hljs-params">(Map&lt;String, Object&gt; context, Exception e)</span> &#123;<br>        log.info(<span class="hljs-string">&quot;静默处理异常&quot;</span>, e);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RpcResponse</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>其它容错策略<br>还可以自行实现更多的容错策略，比如<code>FailBackTolerantStrategy</code>故障恢复策略</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yupi.yurpc.fault.tolerant;<br><br><span class="hljs-keyword">import</span> com.yupi.yurpc.model.RpcResponse;<br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 降级到其他服务 - 容错策略</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> &lt;a href=&quot;https://github.com/liyupi&quot;&gt;程序员鱼皮&lt;/a&gt;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@learn</span> &lt;a href=&quot;https://codefather.cn&quot;&gt;鱼皮的编程宝典&lt;/a&gt;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@from</span> &lt;a href=&quot;https://yupi.icu&quot;&gt;编程导航学习圈&lt;/a&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FailBackTolerantStrategy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">TolerantStrategy</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> RpcResponse <span class="hljs-title function_">doTolerant</span><span class="hljs-params">(Map&lt;String, Object&gt; context, Exception e)</span> &#123;<br>        <span class="hljs-comment">// todo 可自行扩展，获取降级的服务并调用</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>故障转移策略<code>FailOverTolerantStrategy</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yupi.yurpc.fault.tolerant;<br><br><span class="hljs-keyword">import</span> com.yupi.yurpc.model.RpcResponse;<br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 转移到其他服务节点 - 容错策略</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> &lt;a href=&quot;https://github.com/liyupi&quot;&gt;程序员鱼皮&lt;/a&gt;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@learn</span> &lt;a href=&quot;https://codefather.cn&quot;&gt;鱼皮的编程宝典&lt;/a&gt;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@from</span> &lt;a href=&quot;https://yupi.icu&quot;&gt;编程导航学习圈&lt;/a&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FailOverTolerantStrategy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">TolerantStrategy</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> RpcResponse <span class="hljs-title function_">doTolerant</span><span class="hljs-params">(Map&lt;String, Object&gt; context, Exception e)</span> &#123;<br>        <span class="hljs-comment">// todo 可自行扩展，获取其他服务节点并调用</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="支持配置和扩展容错策略"><a href="#支持配置和扩展容错策略" class="headerlink" title="支持配置和扩展容错策略"></a>支持配置和扩展容错策略</h3><p>一个框架可能会支持多种不同的容错策略，因此要能通过填写配置来指定使用的容错策略，并且自定义容错策略</p>
<p>和之前一样，使用工厂创建对象，使用SPI动态加载自定义的容错策略</p>
<ol>
<li>容错策略常量</li>
<li>使用工厂模式，支持根据key从SPI获取容错策略对象实例</li>
<li>在<code>META-INF</code>的<code>rpc/system</code>目录下编写容错策略接口的SPI配置文件，文件名称为<code>com.yupi.yurpc.fault.tolerant.TolerantStrategy</code></li>
<li>为RpcConfig全局配置新增容错策略的配置</li>
</ol>
<h3 id="应用容错功能"><a href="#应用容错功能" class="headerlink" title="应用容错功能"></a>应用容错功能</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 服务代理（JDK 动态代理）</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> &lt;a href=&quot;https://github.com/liyupi&quot;&gt;程序员鱼皮&lt;/a&gt;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@learn</span> &lt;a href=&quot;https://codefather.cn&quot;&gt;编程宝典&lt;/a&gt;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@from</span> &lt;a href=&quot;https://yupi.icu&quot;&gt;编程导航知识星球&lt;/a&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServiceProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 调用代理</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Throwable</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-comment">// 构造请求</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">serviceName</span> <span class="hljs-operator">=</span> method.getDeclaringClass().getName();<br>        <span class="hljs-type">RpcRequest</span> <span class="hljs-variable">rpcRequest</span> <span class="hljs-operator">=</span> RpcRequest.builder()<br>                .serviceName(serviceName)<br>                .methodName(method.getName())<br>                .parameterTypes(method.getParameterTypes())<br>                .args(args)<br>                .build();<br><br>        <span class="hljs-comment">// 从注册中心获取服务提供者请求地址</span><br>        <span class="hljs-type">RpcConfig</span> <span class="hljs-variable">rpcConfig</span> <span class="hljs-operator">=</span> RpcApplication.getRpcConfig();<br>        <span class="hljs-type">Registry</span> <span class="hljs-variable">registry</span> <span class="hljs-operator">=</span> RegistryFactory.getInstance(rpcConfig.getRegistryConfig().getRegistry());<br>        <span class="hljs-type">ServiceMetaInfo</span> <span class="hljs-variable">serviceMetaInfo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServiceMetaInfo</span>();<br>        serviceMetaInfo.setServiceName(serviceName);<br>        serviceMetaInfo.setServiceVersion(RpcConstant.DEFAULT_SERVICE_VERSION);<br>        List&lt;ServiceMetaInfo&gt; serviceMetaInfoList = registry.serviceDiscovery(serviceMetaInfo.getServiceKey());<br>        <span class="hljs-keyword">if</span> (CollUtil.isEmpty(serviceMetaInfoList)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;暂无服务地址&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 负载均衡</span><br>        <span class="hljs-type">LoadBalancer</span> <span class="hljs-variable">loadBalancer</span> <span class="hljs-operator">=</span> LoadBalancerFactory.getInstance(rpcConfig.getLoadBalancer());<br>        <span class="hljs-comment">// 将调用方法名（请求路径）作为负载均衡参数</span><br>        Map&lt;String, Object&gt; requestParams = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        requestParams.put(<span class="hljs-string">&quot;methodName&quot;</span>, rpcRequest.getMethodName());<br>        <span class="hljs-type">ServiceMetaInfo</span> <span class="hljs-variable">selectedServiceMetaInfo</span> <span class="hljs-operator">=</span> loadBalancer.select(requestParams, serviceMetaInfoList);<br>        <span class="hljs-comment">// rpc 请求</span><br>        <span class="hljs-comment">// 使用重试机制</span><br>        RpcResponse rpcResponse;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">RetryStrategy</span> <span class="hljs-variable">retryStrategy</span> <span class="hljs-operator">=</span> RetryStrategyFactory.getInstance(rpcConfig.getRetryStrategy());<br>            rpcResponse = retryStrategy.doRetry(() -&gt;<br>                    VertxTcpClient.doRequest(rpcRequest, selectedServiceMetaInfo)<br>            );<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-comment">// 容错机制</span><br>            <span class="hljs-type">TolerantStrategy</span> <span class="hljs-variable">tolerantStrategy</span> <span class="hljs-operator">=</span> TolerantStrategyFactory.getInstance(rpcConfig.getTolerantStrategy());<br>            rpcResponse = tolerantStrategy.doTolerant(<span class="hljs-literal">null</span>, e);<br>        &#125;<br>        <span class="hljs-keyword">return</span> rpcResponse.getData();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="4-测试-1"><a href="#4-测试-1" class="headerlink" title="4.测试"></a>4.测试</h2><p>。。。。。。</p>
<h2 id="5-扩展-2"><a href="#5-扩展-2" class="headerlink" title="5.扩展"></a>5.扩展</h2><ol>
<li>实现Fail-Back容错机制<br>参考思路：可以参考Dubbo的Mock能力，让消费端指定调用失败要执行的本地服务和方法</li>
<li>实现Fail-Over容错机制<br>参考思路：可以利用容错方法的上下文参数传递所有的服务节点和本次调用的服务节点，选择一个其它节点再次发起调用</li>
<li>实现更多容错方案<code>（较难）</code><br>参考思路：比如限流、熔断、超时控制等。或者将重试机制作为容错机制的一种策略来实现</li>
</ol>
<h1 id="十、启动机制和注解驱动"><a href="#十、启动机制和注解驱动" class="headerlink" title="十、启动机制和注解驱动"></a>十、启动机制和注解驱动</h1><h2 id="1-需求分析-9"><a href="#1-需求分析-9" class="headerlink" title="1.需求分析"></a>1.需求分析</h2><p>经过前面的步骤，框架的功能已经比较完善了，但是框架是给开发者用的，那么用户会更关注哪些方面：</p>
<ul>
<li>框架的知名度和用户数：尽量选主流的、用户多的、经过了充分的市场验证</li>
<li>生态和社区活跃度：尽量选择社区活跃的、能和其它技术兼容的</li>
<li>简单易用上手：最好开箱即用，不用花很多时间上手。</li>
</ul>
<p>而反观我们的框架，光是示例服务提供者的代码就非常长，因此本节<code>优化框架的易用性</code>，通过建立合适的<code>启动机制</code>和<code>注解驱动机制</code>，帮助开发者最少只用一行代码，就能轻松使用框架</p>
<h2 id="2-设计方案-7"><a href="#2-设计方案-7" class="headerlink" title="2.设计方案"></a>2.设计方案</h2><h3 id="启动机制设计"><a href="#启动机制设计" class="headerlink" title="启动机制设计"></a>启动机制设计</h3><p>将所有启动代码封装成一个<code>专门的启动类</code>或方法，然后由服务提供者&#x2F;服务消费者调用即可</p>
<p>但是有一点我们需要注意，服务提供者和消费者需要初始化的模块是不同的，比如服务消费者不需要启动Web服务器</p>
<p>所以我们需要针对服务提供者和消费者分别编写一个启动类，如果是二者都需要初始化的模块，可以放到全局应用类<code>RpcApplication</code>中，复用代码的同时保证启动类的可维护、可扩展性。</p>
<h3 id="注解驱动设计"><a href="#注解驱动设计" class="headerlink" title="注解驱动设计"></a>注解驱动设计</h3><p>除了启动类之外，还有一种其它方式能帮助开发者使用框架——<code>注解驱动</code></p>
<p>学过Dubbo这款框架可以知道，开发者只需要在服务提供者实现类上打上一个<code>DubboService</code>注解，就能快速注册服务，同样的，只需要在服务消费者字段上打上一个<code>DubboReference</code>注解，就能快速使用服务</p>
<p class='item-img' data-src='C:\Users\新\AppData\Roaming\Typora\typora-user-images\image-20241029223547109.png'><img src="C:\Users\新\AppData\Roaming\Typora\typora-user-images\image-20241029223547109.png" alt="image-20241029223547109"></p>
<p>由于现在的java项目基本都使用Spring Boot框架，所以Dubbo还贴心的推出了Spring Boot Starter，用更少的代码在Spring Boot项目中使用框架</p>
<p>那我们也可以创建一个Spring Boot Starter项目，并通过注解驱动框架的初始化，完成服务的注册和获取引用</p>
<h3 id="实现注解驱动的两种方法"><a href="#实现注解驱动的两种方法" class="headerlink" title="实现注解驱动的两种方法"></a>实现注解驱动的两种方法</h3><ol>
<li>主动扫描：让开发者指定要扫描的路径，然后遍历所有的类文件，针对有注解的类文件，执行自定义操作</li>
<li>监听Bean加载：在Spring项目中，可以通过实现BeanPostProcessor接口，在Bean初始化后执行自定义操作</li>
</ol>
<h2 id="3-开发实现-6"><a href="#3-开发实现-6" class="headerlink" title="3.开发实现"></a>3.开发实现</h2><h3 id="启动机制"><a href="#启动机制" class="headerlink" title="启动机制"></a>启动机制</h3><p>在项目中新建包名<code>bootstrap</code>,所有和框架启动初始化相关的代码都放到该包下</p>
<h4 id="服务提供者启动类"><a href="#服务提供者启动类" class="headerlink" title="服务提供者启动类"></a>服务提供者启动类</h4><p>新建<code>ProviderBootstrap</code>类，先直接复制之前服务提供示例项目中的初始化代码，然后略微改造，支持用户传入自己要注册的服务</p>
<p>在注册服务时，我们需要填入多个字段，比如服务名称、服务实现类参考代码</p>
<p><code>model</code>包下新建<code>ServiceRegisterInfo</code>类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yupi.yurpc.model;<br><br><span class="hljs-keyword">import</span> lombok.AllArgsConstructor;<br><span class="hljs-keyword">import</span> lombok.Data;<br><span class="hljs-keyword">import</span> lombok.NoArgsConstructor;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 服务注册信息类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServiceRegisterInfo</span>&lt;T&gt; &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 服务名称</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String serviceName;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 实现类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">T</span>&gt; implClass;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>服务提供者完整代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yupi.yurpc.bootstrap;<br><br><span class="hljs-keyword">import</span> com.yupi.yurpc.RpcApplication;<br><span class="hljs-keyword">import</span> com.yupi.yurpc.config.RegistryConfig;<br><span class="hljs-keyword">import</span> com.yupi.yurpc.config.RpcConfig;<br><span class="hljs-keyword">import</span> com.yupi.yurpc.model.ServiceMetaInfo;<br><span class="hljs-keyword">import</span> com.yupi.yurpc.model.ServiceRegisterInfo;<br><span class="hljs-keyword">import</span> com.yupi.yurpc.registry.LocalRegistry;<br><span class="hljs-keyword">import</span> com.yupi.yurpc.registry.Registry;<br><span class="hljs-keyword">import</span> com.yupi.yurpc.registry.RegistryFactory;<br><span class="hljs-keyword">import</span> com.yupi.yurpc.server.tcp.VertxTcpServer;<br><br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 服务提供者初始化</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProviderBootstrap</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 初始化</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(List&lt;ServiceRegisterInfo&lt;?&gt;&gt; serviceRegisterInfoList)</span> &#123;<br>        <span class="hljs-comment">// RPC 框架初始化（配置和注册中心）</span><br>        RpcApplication.init();<br>        <span class="hljs-comment">// 全局配置</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">RpcConfig</span> <span class="hljs-variable">rpcConfig</span> <span class="hljs-operator">=</span> RpcApplication.getRpcConfig();<br><br>        <span class="hljs-comment">// 注册服务</span><br>        <span class="hljs-keyword">for</span> (ServiceRegisterInfo&lt;?&gt; serviceRegisterInfo : serviceRegisterInfoList) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">serviceName</span> <span class="hljs-operator">=</span> serviceRegisterInfo.getServiceName();<br>            <span class="hljs-comment">// 本地注册</span><br>            LocalRegistry.register(serviceName, serviceRegisterInfo.getImplClass());<br><br>            <span class="hljs-comment">// 注册服务到注册中心</span><br>            <span class="hljs-type">RegistryConfig</span> <span class="hljs-variable">registryConfig</span> <span class="hljs-operator">=</span> rpcConfig.getRegistryConfig();<br>            <span class="hljs-type">Registry</span> <span class="hljs-variable">registry</span> <span class="hljs-operator">=</span> RegistryFactory.getInstance(registryConfig.getRegistry());<br>            <span class="hljs-type">ServiceMetaInfo</span> <span class="hljs-variable">serviceMetaInfo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServiceMetaInfo</span>();<br>            serviceMetaInfo.setServiceName(serviceName);<br>            serviceMetaInfo.setServiceHost(rpcConfig.getServerHost());<br>            serviceMetaInfo.setServicePort(rpcConfig.getServerPort());<br>            <span class="hljs-keyword">try</span> &#123;<br>                registry.register(serviceMetaInfo);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(serviceName + <span class="hljs-string">&quot; 服务注册失败&quot;</span>, e);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 启动服务器</span><br>        <span class="hljs-type">VertxTcpServer</span> <span class="hljs-variable">vertxTcpServer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VertxTcpServer</span>();<br>        vertxTcpServer.doStart(rpcConfig.getServerPort());<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>在服务提供者中使用RPC框架，直接一行代码调用即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yupi.example.provider;<br><br><span class="hljs-keyword">import</span> com.yupi.example.common.service.UserService;<br><span class="hljs-keyword">import</span> com.yupi.yurpc.bootstrap.ProviderBootstrap;<br><span class="hljs-keyword">import</span> com.yupi.yurpc.model.ServiceRegisterInfo;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 服务提供者示例</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> &lt;a href=&quot;https://github.com/liyupi&quot;&gt;程序员鱼皮&lt;/a&gt;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@learn</span> &lt;a href=&quot;https://codefather.cn&quot;&gt;编程宝典&lt;/a&gt;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@from</span> &lt;a href=&quot;https://yupi.icu&quot;&gt;编程导航知识星球&lt;/a&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProviderExample</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 要注册的服务</span><br>        List&lt;ServiceRegisterInfo&gt; serviceRegisterInfoList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">ServiceRegisterInfo</span> <span class="hljs-variable">serviceRegisterInfo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServiceRegisterInfo</span>(UserService.class.getName(), UserServiceImpl.class);<br>        serviceRegisterInfoList.add(serviceRegisterInfo);<br><br>        <span class="hljs-comment">// 服务提供者初始化</span><br>        ProviderBootstrap.init(serviceRegisterInfoList);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="服务消费者启动类"><a href="#服务消费者启动类" class="headerlink" title="服务消费者启动类"></a>服务消费者启动类</h4><p>由于服务消费者不需要注册服务，也不需要启动Web服务，只需要执行RpcApplicaiton.init完成框架的通用初始化即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yupi.yurpc.bootstrap;<br><br><span class="hljs-keyword">import</span> com.yupi.yurpc.RpcApplication;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 服务消费者启动类（初始化）</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> &lt;a href=&quot;https://github.com/liyupi&quot;&gt;程序员鱼皮&lt;/a&gt;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@learn</span> &lt;a href=&quot;https://codefather.cn&quot;&gt;鱼皮的编程宝典&lt;/a&gt;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@from</span> &lt;a href=&quot;https://yupi.icu&quot;&gt;编程导航学习圈&lt;/a&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConsumerBootstrap</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 初始化</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// RPC 框架初始化（配置和注册中心）</span><br>        RpcApplication.init();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Spring-Boot-Starter注解驱动"><a href="#Spring-Boot-Starter注解驱动" class="headerlink" title="Spring Boot Starter注解驱动"></a>Spring Boot Starter注解驱动</h3><p>为了便于学习，不和已有的项目代码混淆，创建一个新的模块，专门用于实现注解驱动框架</p>
<p>Dubbo是在框架内引入了spring-context，会让整个框架更内聚，但是不利于学习理解</p>
<h4 id="（1）Spring-Boot-Starter项目初始化"><a href="#（1）Spring-Boot-Starter项目初始化" class="headerlink" title="（1）Spring Boot Starter项目初始化"></a>（1）Spring Boot Starter项目初始化</h4><p>新建SpringBoot项目，并删除pom中的无用插件即可</p>
<h4 id="（2）定义注解"><a href="#（2）定义注解" class="headerlink" title="（2）定义注解"></a>（2）定义注解</h4><p>参考知名框架Dubbo的注解</p>
<p>例如：</p>
<ol>
<li><code>@EnableDubbo</code>：在SpringBoot主应用类上使用，用于启用Dubbo功能</li>
<li><code>@DubboComponentScan</code>：在Spring Boot主应用类上使用，用于指定Dubbo组件扫描的包路径</li>
<li><code>@DubboReference</code>：在消费者中使用，用于声明Dubbo服务</li>
<li><code>@DubboMethod</code>：在提供者和消费者中使用，用于配置Dubbo方法的参数，超时时间等</li>
<li><code>@DubboTransported</code>：在Dubbo提供者和消费者中使用，用于指定传输协议和参数，例如传输协议的类型、端口等</li>
</ol>
<p>当然，这些注解我们不需要全部用到，遵循最小可用原则，我们只需要定义3个注解，新建<code>annotation</code>包，将所有注解代码放到该包下</p>
<p class='item-img' data-src='C:\Users\新\AppData\Roaming\Typora\typora-user-images\image-20241030210349284.png'><img src="C:\Users\新\AppData\Roaming\Typora\typora-user-images\image-20241030210349284.png" alt="image-20241030210349284"></p>
<ol>
<li><p>@EnableRpc：用于全局标识项目需要引入RPC框架，执行初始化方法<br>由于服务消费者和服务提供者初始化的模块不同，需要在EnableRpc注解中，指定是否需要启动服务器等属性，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yupi.yurpc.springboot.starter.annotation;<br><br><span class="hljs-keyword">import</span> com.yupi.yurpc.springboot.starter.bootstrap.RpcConsumerBootstrap;<br><span class="hljs-keyword">import</span> com.yupi.yurpc.springboot.starter.bootstrap.RpcInitBootstrap;<br><span class="hljs-keyword">import</span> com.yupi.yurpc.springboot.starter.bootstrap.RpcProviderBootstrap;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Import;<br><br><span class="hljs-keyword">import</span> java.lang.annotation.*;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 启用 Rpc 注解</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableRpc &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 需要启动 server</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">needServer</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>@RpcService：服务提供者注解，在需要注册和提供的服务类上使用<br>该注解中，需要指定服务注册信息属性，比如服务接口实现类、版本号等（也可以包括服务名称）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yupi.yurpc.springboot.starter.annotation;<br><br><span class="hljs-keyword">import</span> com.yupi.yurpc.constant.RpcConstant;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-keyword">import</span> java.lang.annotation.ElementType;<br><span class="hljs-keyword">import</span> java.lang.annotation.Retention;<br><span class="hljs-keyword">import</span> java.lang.annotation.RetentionPolicy;<br><span class="hljs-keyword">import</span> java.lang.annotation.Target;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 服务提供者注解（用于注册服务）</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> &lt;a href=&quot;https://github.com/liyupi&quot;&gt;程序员鱼皮&lt;/a&gt;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@learn</span> &lt;a href=&quot;https://codefather.cn&quot;&gt;程序员鱼皮的编程宝典&lt;/a&gt;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@from</span> &lt;a href=&quot;https://yupi.icu&quot;&gt;编程导航知识星球&lt;/a&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> RpcService &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 服务接口类</span><br><span class="hljs-comment">     */</span><br>    Class&lt;?&gt; interfaceClass() <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span>.class;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 版本</span><br><span class="hljs-comment">     */</span><br>    String <span class="hljs-title function_">serviceVersion</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> RpcConstant.DEFAULT_SERVICE_VERSION;<br>&#125;<br></code></pre></td></tr></table></figure>


</li>
<li><p>@RpcReference：服务消费者注解，在需要注入服务代理对象的属性上使用，类似Spring中的@Resource注解<br>RpcReference注解中，需要指定调用服务相关的属性，比如服务接口类（可能存在多个接口）、版本号、负载均衡器、重试策略、是否Mock模拟调用等</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yupi.yurpc.springboot.starter.annotation;<br><br><span class="hljs-keyword">import</span> com.yupi.yurpc.constant.RpcConstant;<br><span class="hljs-keyword">import</span> com.yupi.yurpc.fault.retry.RetryStrategyKeys;<br><span class="hljs-keyword">import</span> com.yupi.yurpc.fault.tolerant.TolerantStrategyKeys;<br><span class="hljs-keyword">import</span> com.yupi.yurpc.loadbalancer.LoadBalancerKeys;<br><br><span class="hljs-keyword">import</span> java.lang.annotation.ElementType;<br><span class="hljs-keyword">import</span> java.lang.annotation.Retention;<br><span class="hljs-keyword">import</span> java.lang.annotation.RetentionPolicy;<br><span class="hljs-keyword">import</span> java.lang.annotation.Target;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 服务消费者注解（用于注入服务）</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> &lt;a href=&quot;https://github.com/liyupi&quot;&gt;程序员鱼皮&lt;/a&gt;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@learn</span> &lt;a href=&quot;https://codefather.cn&quot;&gt;程序员鱼皮的编程宝典&lt;/a&gt;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@from</span> &lt;a href=&quot;https://yupi.icu&quot;&gt;编程导航知识星球&lt;/a&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.FIELD)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> RpcReference &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 服务接口类</span><br><span class="hljs-comment">     */</span><br>    Class&lt;?&gt; interfaceClass() <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span>.class;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 版本</span><br><span class="hljs-comment">     */</span><br>    String <span class="hljs-title function_">serviceVersion</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> RpcConstant.DEFAULT_SERVICE_VERSION;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 负载均衡器</span><br><span class="hljs-comment">     */</span><br>    String <span class="hljs-title function_">loadBalancer</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> LoadBalancerKeys.ROUND_ROBIN;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 重试策略</span><br><span class="hljs-comment">     */</span><br>    String <span class="hljs-title function_">retryStrategy</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> RetryStrategyKeys.NO;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 容错策略</span><br><span class="hljs-comment">     */</span><br>    String <span class="hljs-title function_">tolerantStrategy</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> TolerantStrategyKeys.FAIL_FAST;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 模拟调用</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">mock</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-literal">false</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h4 id="（3）注解驱动"><a href="#（3）注解驱动" class="headerlink" title="（3）注解驱动"></a>（3）注解驱动</h4><p>starter项目中新建<code>bootstrap</code>包，并且分别针对上面定义的3个注解新建启动类</p>
<p class='item-img' data-src='C:\Users\新\AppData\Roaming\Typora\typora-user-images\image-20241030212532688.png'><img src="C:\Users\新\AppData\Roaming\Typora\typora-user-images\image-20241030212532688.png" alt="image-20241030212532688"></p>
<ul>
<li><p>Rpc框架全局启动类：<code>RpcInitBootstrap</code><br>需求是在Spring框架初始化时，获取@EnableRpc的注解的属性，并初始化RPC框架<br>怎么获取到注解的属性呢？<br>可以实现Spring的<code>ImportBeanDefinitionRegistrar</code>接口，并在<code>registerBeanDefinitions</code>方法中，获取到项目的注解和注解属性<br><code>ImportBeanDefinitionRegistrar</code>:支持我们自己写的代码封装成<code>BeanDefinition对象</code>,注册到Spring容器中，但是<code>ImportBeanDefinitionRegistrar接口实现类</code>，只能通过<code>@Import注解</code>的方式来注入<br>其中第一个参数：正在处理的注解类的元数据信息<br>第二个参数：允许将新的Bean定义注册到Spring容器中</p>
<p>注意：实现ImportBeanDefinitionRegistrar接口的类需要通过@Import导入，该类的方法会在容器初始化（容器初始化完成之后才会开始Bean的生命周期）的时候被执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yupi.yurpc.springboot.starter.bootstrap;<br><br><span class="hljs-keyword">import</span> com.yupi.yurpc.RpcApplication;<br><span class="hljs-keyword">import</span> com.yupi.yurpc.config.RpcConfig;<br><span class="hljs-keyword">import</span> com.yupi.yurpc.server.tcp.VertxTcpServer;<br><span class="hljs-keyword">import</span> com.yupi.yurpc.springboot.starter.annotation.EnableRpc;<br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.support.BeanDefinitionRegistry;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.ImportBeanDefinitionRegistrar;<br><span class="hljs-keyword">import</span> org.springframework.core.type.AnnotationMetadata;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Rpc 框架启动</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> &lt;a href=&quot;https://github.com/liyupi&quot;&gt;程序员鱼皮&lt;/a&gt;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@learn</span> &lt;a href=&quot;https://codefather.cn&quot;&gt;程序员鱼皮的编程宝典&lt;/a&gt;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@from</span> &lt;a href=&quot;https://yupi.icu&quot;&gt;编程导航知识星球&lt;/a&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RpcInitBootstrap</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ImportBeanDefinitionRegistrar</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Spring 初始化时执行，初始化 RPC 框架</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> importingClassMetadata</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> registry</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerBeanDefinitions</span><span class="hljs-params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> &#123;<br>        <span class="hljs-comment">// 获取 EnableRpc 注解的属性值</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">needServer</span> <span class="hljs-operator">=</span> (<span class="hljs-type">boolean</span>) importingClassMetadata.getAnnotationAttributes(EnableRpc.class.getName())<br>                .get(<span class="hljs-string">&quot;needServer&quot;</span>);<br><br>        <span class="hljs-comment">// RPC 框架初始化（配置和注册中心）</span><br>        RpcApplication.init();<br><br>        <span class="hljs-comment">// 全局配置</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">RpcConfig</span> <span class="hljs-variable">rpcConfig</span> <span class="hljs-operator">=</span> RpcApplication.getRpcConfig();<br><br>        <span class="hljs-comment">// 启动服务器</span><br>        <span class="hljs-keyword">if</span> (needServer) &#123;<br>            <span class="hljs-type">VertxTcpServer</span> <span class="hljs-variable">vertxTcpServer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VertxTcpServer</span>();<br>            vertxTcpServer.doStart(rpcConfig.getServerPort());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            log.info(<span class="hljs-string">&quot;不启动 server&quot;</span>);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>Rpc服务提供者启动类<code>RpcProviderBootstrap</code><br>服务提供者启动类的作用：获取到所有包含<code>@RpcService</code>注解的类，并且通过注解的属性和反射机制，获取到要注册的服务信息，并且完成服务注册<br>怎么获取到所有包含@RpcService注解的类呢？<br>像前面设计方案中提到的，可以主动扫描包，也可以利用Spring的特性监听Bean的加载<br>此处选择后者，实现更简单，而且能直接获取到服务提供者的Bean对象<br>只需要让启动类实现<code>BeanPostProcessor</code>接口的<code>postProcessAfterInitialization</code>方法，就可以在某个服务提供者Bean初始化后，执行注册服务等操作了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yupi.yurpc.springboot.starter.bootstrap;<br><br><span class="hljs-keyword">import</span> com.yupi.yurpc.RpcApplication;<br><span class="hljs-keyword">import</span> com.yupi.yurpc.config.RegistryConfig;<br><span class="hljs-keyword">import</span> com.yupi.yurpc.config.RpcConfig;<br><span class="hljs-keyword">import</span> com.yupi.yurpc.model.ServiceMetaInfo;<br><span class="hljs-keyword">import</span> com.yupi.yurpc.registry.LocalRegistry;<br><span class="hljs-keyword">import</span> com.yupi.yurpc.registry.Registry;<br><span class="hljs-keyword">import</span> com.yupi.yurpc.registry.RegistryFactory;<br><span class="hljs-keyword">import</span> com.yupi.yurpc.springboot.starter.annotation.RpcService;<br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><span class="hljs-keyword">import</span> org.springframework.beans.BeansException;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.config.BeanPostProcessor;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Rpc 服务提供者启动</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> &lt;a href=&quot;https://github.com/liyupi&quot;&gt;程序员鱼皮&lt;/a&gt;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@learn</span> &lt;a href=&quot;https://codefather.cn&quot;&gt;程序员鱼皮的编程宝典&lt;/a&gt;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@from</span> &lt;a href=&quot;https://yupi.icu&quot;&gt;编程导航知识星球&lt;/a&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RpcProviderBootstrap</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanPostProcessor</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Bean 初始化后执行，注册服务</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bean</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> beanName</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> BeansException</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        Class&lt;?&gt; beanClass = bean.getClass();<br>        <span class="hljs-type">RpcService</span> <span class="hljs-variable">rpcService</span> <span class="hljs-operator">=</span> beanClass.getAnnotation(RpcService.class);<br>        <span class="hljs-keyword">if</span> (rpcService != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 需要注册服务</span><br>            <span class="hljs-comment">// 1. 获取服务基本信息</span><br>            Class&lt;?&gt; interfaceClass = rpcService.interfaceClass();<br>            <span class="hljs-comment">// 默认值处理</span><br>            <span class="hljs-keyword">if</span> (interfaceClass == <span class="hljs-keyword">void</span>.class) &#123;<br>                interfaceClass = beanClass.getInterfaces()[<span class="hljs-number">0</span>];<br>            &#125;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">serviceName</span> <span class="hljs-operator">=</span> interfaceClass.getName();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">serviceVersion</span> <span class="hljs-operator">=</span> rpcService.serviceVersion();<br>            <span class="hljs-comment">// 2. 注册服务</span><br>            <span class="hljs-comment">// 本地注册</span><br>            LocalRegistry.register(serviceName, beanClass);<br><br>            <span class="hljs-comment">// 全局配置</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">RpcConfig</span> <span class="hljs-variable">rpcConfig</span> <span class="hljs-operator">=</span> RpcApplication.getRpcConfig();<br>            <span class="hljs-comment">// 注册服务到注册中心</span><br>            <span class="hljs-type">RegistryConfig</span> <span class="hljs-variable">registryConfig</span> <span class="hljs-operator">=</span> rpcConfig.getRegistryConfig();<br>            <span class="hljs-type">Registry</span> <span class="hljs-variable">registry</span> <span class="hljs-operator">=</span> RegistryFactory.getInstance(registryConfig.getRegistry());<br>            <span class="hljs-type">ServiceMetaInfo</span> <span class="hljs-variable">serviceMetaInfo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServiceMetaInfo</span>();<br>            serviceMetaInfo.setServiceName(serviceName);<br>            serviceMetaInfo.setServiceVersion(serviceVersion);<br>            serviceMetaInfo.setServiceHost(rpcConfig.getServerHost());<br>            serviceMetaInfo.setServicePort(rpcConfig.getServerPort());<br>            <span class="hljs-keyword">try</span> &#123;<br>                registry.register(serviceMetaInfo);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(serviceName + <span class="hljs-string">&quot; 服务注册失败&quot;</span>, e);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> BeanPostProcessor.<span class="hljs-built_in">super</span>.postProcessAfterInitialization(bean, beanName);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
</li>
<li><p>Rpc服务消费者启动类<code>RpcConsumerBootstrap</code><br>和服务提供者启动类的实现方式类似，在bean初始化后，通过反射获取到bean的所有属性，如果属性包含@RpcReference注解，那么就为该属性动态生成代理对象并赋值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yupi.yurpc.springboot.starter.bootstrap;<br><br><span class="hljs-keyword">import</span> com.yupi.yurpc.proxy.ServiceProxyFactory;<br><span class="hljs-keyword">import</span> com.yupi.yurpc.springboot.starter.annotation.RpcReference;<br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><span class="hljs-keyword">import</span> org.springframework.beans.BeansException;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.config.BeanPostProcessor;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Rpc 服务消费者启动</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> &lt;a href=&quot;https://github.com/liyupi&quot;&gt;程序员鱼皮&lt;/a&gt;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@learn</span> &lt;a href=&quot;https://codefather.cn&quot;&gt;程序员鱼皮的编程宝典&lt;/a&gt;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@from</span> &lt;a href=&quot;https://yupi.icu&quot;&gt;编程导航知识星球&lt;/a&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RpcConsumerBootstrap</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanPostProcessor</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Bean 初始化后执行，注入服务</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bean</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> beanName</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> BeansException</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        Class&lt;?&gt; beanClass = bean.getClass();<br>        <span class="hljs-comment">// 遍历对象的所有属性</span><br>        Field[] declaredFields = beanClass.getDeclaredFields();<br>        <span class="hljs-keyword">for</span> (Field field : declaredFields) &#123;<br>            <span class="hljs-type">RpcReference</span> <span class="hljs-variable">rpcReference</span> <span class="hljs-operator">=</span> field.getAnnotation(RpcReference.class);<br>            <span class="hljs-keyword">if</span> (rpcReference != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 为属性生成代理对象</span><br>                Class&lt;?&gt; interfaceClass = rpcReference.interfaceClass();<br>                <span class="hljs-keyword">if</span> (interfaceClass == <span class="hljs-keyword">void</span>.class) &#123;<br>                    interfaceClass = field.getType();<br>                &#125;<br>                field.setAccessible(<span class="hljs-literal">true</span>);<br>                <span class="hljs-type">Object</span> <span class="hljs-variable">proxyObject</span> <span class="hljs-operator">=</span> ServiceProxyFactory.getProxy(interfaceClass);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    field.set(bean, proxyObject);<br>                    field.setAccessible(<span class="hljs-literal">false</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;为字段注入代理对象失败&quot;</span>, e);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> BeanPostProcessor.<span class="hljs-built_in">super</span>.postProcessAfterInitialization(bean, beanName);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>注册已编写的启动类<br>最后别忘了在Spring中加载我们已经编写好的启动类<br>如何加载呢？<br>需求是，仅在用户使用<code>@EnableRp</code>c注解时，才启动RPC框架，所以，可以通过给Enable增加<code>@Import</code>注解，来注册我们自定义的启动类，实现灵活的可选加载<br>修改后的Enable注解代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Import(&#123;RpcInitBootstrap.class, RpcProviderBootstrap.class, RpcConsumerBootstrap.class&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableRpc &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 需要启动 server</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">needServer</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="4-测试-2"><a href="#4-测试-2" class="headerlink" title="4.测试"></a>4.测试</h2><p>。。。。。。</p>
<h2 id="5-扩展-3"><a href="#5-扩展-3" class="headerlink" title="5.扩展"></a>5.扩展</h2><ol>
<li>Spring Boot Starter项目支持读取yml&#x2F;yaml配置文件来启动RPC框架<br>参考思路：像读取properties文件一样，提供一个工具类来读取yml配置<br>服务提供者启动逻辑也可以改bean后置执行为“使用组件扫描”</li>
</ol>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2025/01/03/%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">← Next </a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2025/01/03/WEB%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0/"> Prev →</a></div></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="To Top" style="opacity: 0; display: none;">∧ </a><a class="i-index" id="to-index" href="#toc-div" title="To Catalog">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="Change Theme"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo" style="margin:0;border-radius:0;"></a><h1 id="Dr"><a href="/">John Doe</a></h1><div id="description"><p></p></div></div><div id="aside-block"><div id="toc-div"><h1>Catalog</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BC%96%E7%A8%8B%E5%AF%BC%E8%88%AA%EF%BC%9ARPC%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E6%A1%86%E6%9E%B6%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Vserion2-0"><span class="toc-number">1.</span> <span class="toc-text">编程导航：RPC远程调用框架的学习笔记-Vserion2.0</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE%E5%8A%A0%E8%BD%BD"><span class="toc-number">2.</span> <span class="toc-text">一、全局配置加载</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90"><span class="toc-number">2.1.</span> <span class="toc-text">1.需求分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88"><span class="toc-number">2.2.</span> <span class="toc-text">2.设计方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E9%A1%B9"><span class="toc-number">2.2.1.</span> <span class="toc-text">配置项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%8F%96"><span class="toc-number">2.2.2.</span> <span class="toc-text">配置文件的读取</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%BC%80%E5%8F%91%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.3.</span> <span class="toc-text">3.开发实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.4.</span> <span class="toc-text">项目实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E5%8A%A0%E8%BD%BD"><span class="toc-number">2.5.</span> <span class="toc-text">配置加载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%B4%E6%8A%A4%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.6.</span> <span class="toc-text">维护全局配置对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95"><span class="toc-number">2.7.</span> <span class="toc-text">测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E6%80%9D%E8%B7%AF"><span class="toc-number">2.8.</span> <span class="toc-text">扩展思路</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%8E%A5%E5%8F%A3Mock"><span class="toc-number">3.</span> <span class="toc-text">二、接口Mock</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90-1"><span class="toc-number">3.1.</span> <span class="toc-text">1.需求分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFmock"><span class="toc-number">3.1.1.</span> <span class="toc-text">什么是mock?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%94%AF%E6%8C%81mock"><span class="toc-number">3.1.2.</span> <span class="toc-text">为什么要支持mock</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88-1"><span class="toc-number">3.2.</span> <span class="toc-text">2.设计方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E6%A8%A1%E6%8B%9F%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="toc-number">3.2.1.</span> <span class="toc-text">如何创建模拟对象？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E5%8F%91%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.2.2.</span> <span class="toc-text">开发实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95-1"><span class="toc-number">3.2.3.</span> <span class="toc-text">测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E6%80%9D%E8%B7%AF-1"><span class="toc-number">3.2.4.</span> <span class="toc-text">扩展思路</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8%E5%92%8CSPI%E6%9C%BA%E5%88%B6"><span class="toc-number">4.</span> <span class="toc-text">三、序列化器和SPI机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90-2"><span class="toc-number">4.1.</span> <span class="toc-text">1.需求分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88-2"><span class="toc-number">4.2.</span> <span class="toc-text">2.设计方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%BC%80%E5%8F%91%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">4.3.</span> <span class="toc-text">3.开发实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%A7%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.3.1.</span> <span class="toc-text">多种序列化器的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E4%BD%BF%E7%94%A8%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8"><span class="toc-number">4.3.2.</span> <span class="toc-text">动态使用序列化器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8"><span class="toc-number">4.3.3.</span> <span class="toc-text">自定义序列化器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%89%A9%E5%B1%95%E6%80%9D%E8%B7%AF"><span class="toc-number">4.4.</span> <span class="toc-text">4.扩展思路</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.</span> <span class="toc-text">四、注册中心基本实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90-3"><span class="toc-number">5.1.</span> <span class="toc-text">1.需求分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88-3"><span class="toc-number">5.2.</span> <span class="toc-text">2.设计方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B"><span class="toc-number">5.2.1.</span> <span class="toc-text">技术选型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Etcd%E5%85%A5%E9%97%A8"><span class="toc-number">5.2.1.1.</span> <span class="toc-text">Etcd入门</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Etcd%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%89%B9%E6%80%A7"><span class="toc-number">5.2.1.2.</span> <span class="toc-text">Etcd数据结构与特性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">5.2.2.</span> <span class="toc-text">存储结构设计</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%BC%80%E5%8F%91%E5%AE%9E%E7%8E%B0-2"><span class="toc-number">5.3.</span> <span class="toc-text">3.开发实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%BC%80%E5%8F%91"><span class="toc-number">5.3.1.</span> <span class="toc-text">注册中心开发</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E4%BC%98%E5%8C%96"><span class="toc-number">6.</span> <span class="toc-text">五、注册中心优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90-4"><span class="toc-number">6.1.</span> <span class="toc-text">1.需求分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E4%BC%98%E5%8C%96"><span class="toc-number">6.2.</span> <span class="toc-text">2.注册中心优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%83%E8%B7%B3%E6%A3%80%E6%B5%8B%E5%92%8C%E7%BB%AD%E6%9C%9F%E6%9C%BA%E5%88%B6"><span class="toc-number">6.2.1.</span> <span class="toc-text">心跳检测和续期机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1"><span class="toc-number">6.2.1.1.</span> <span class="toc-text">方案设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E5%8F%91%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">6.2.1.2.</span> <span class="toc-text">开发实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95-2"><span class="toc-number">6.2.1.3.</span> <span class="toc-text">测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E8%8A%82%E7%82%B9%E4%B8%8B%E7%BA%BF%E6%9C%BA%E5%88%B6"><span class="toc-number">6.2.2.</span> <span class="toc-text">服务节点下线机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1-1"><span class="toc-number">6.2.2.1.</span> <span class="toc-text">方案设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E5%8F%91%E5%AE%9E%E7%8E%B0-2"><span class="toc-number">6.2.2.2.</span> <span class="toc-text">开发实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95-3"><span class="toc-number">6.2.2.3.</span> <span class="toc-text">测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E7%AB%AF%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98"><span class="toc-number">6.2.3.</span> <span class="toc-text">消费端服务缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A2%9E%E5%8A%A0%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98"><span class="toc-number">6.2.3.1.</span> <span class="toc-text">增加本地缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98"><span class="toc-number">6.2.3.2.</span> <span class="toc-text">使用本地缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0-%E7%9B%91%E5%90%AC%E6%9C%BA%E5%88%B6"><span class="toc-number">6.2.3.3.</span> <span class="toc-text">服务缓存更新-监听机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95-4"><span class="toc-number">6.2.3.4.</span> <span class="toc-text">测试</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Zookeeper%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%AE%9E%E7%8E%B0%EF%BC%88%E9%9D%9E%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">6.3.</span> <span class="toc-text">3.Zookeeper注册中心实现（非重点）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%89%A9%E5%B1%95"><span class="toc-number">6.4.</span> <span class="toc-text">4.扩展</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8D%8F%E8%AE%AE"><span class="toc-number">7.</span> <span class="toc-text">六、自定义协议</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90-5"><span class="toc-number">7.1.</span> <span class="toc-text">1.需求分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88-4"><span class="toc-number">7.2.</span> <span class="toc-text">2.设计方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE"><span class="toc-number">7.2.1.</span> <span class="toc-text">网络传输协议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">7.3.</span> <span class="toc-text">消息结构设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%BC%80%E5%8F%91%E5%AE%9E%E7%8E%B0-3"><span class="toc-number">7.4.</span> <span class="toc-text">3.开发实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E7%BB%93%E6%9E%84"><span class="toc-number">7.4.1.</span> <span class="toc-text">消息结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93"><span class="toc-number">7.4.2.</span> <span class="toc-text">网络传输</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A0%81-%E8%A7%A3%E7%A0%81"><span class="toc-number">7.4.3.</span> <span class="toc-text">编码&#x2F;解码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%B2%98%E5%8C%85%E5%8D%8A%E5%8C%85%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3"><span class="toc-number">7.5.</span> <span class="toc-text">4.粘包半包问题解决</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%B2%98%E5%8C%85%E5%92%8C%E5%8D%8A%E5%8C%85%EF%BC%9F%EF%BC%9A"><span class="toc-number">7.5.1.</span> <span class="toc-text">什么是粘包和半包？：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8A%E5%8C%85%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98%E7%9A%84%E6%BC%94%E7%A4%BA"><span class="toc-number">7.5.2.</span> <span class="toc-text">半包粘包问题的演示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%8D%8A%E5%8C%85%EF%BC%9F"><span class="toc-number">7.5.3.</span> <span class="toc-text">如何解决半包？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%B2%98%E5%8C%85%EF%BC%9F"><span class="toc-number">7.5.4.</span> <span class="toc-text">如何解决粘包？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vertx%E8%A7%A3%E5%86%B3%E5%8D%8A%E5%8C%85%E5%92%8C%E7%B2%98%E5%8C%85"><span class="toc-number">7.5.5.</span> <span class="toc-text">Vertx解决半包和粘包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81"><span class="toc-number">7.5.5.1.</span> <span class="toc-text">测试代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E8%BF%90%E7%94%A8"><span class="toc-number">7.5.5.2.</span> <span class="toc-text">实际运用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%81%E8%A3%85%E5%8D%8A%E5%8C%85%E7%B2%98%E5%8C%85%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">7.5.5.3.</span> <span class="toc-text">封装半包粘包处理器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%89%A9%E5%B1%95"><span class="toc-number">7.6.</span> <span class="toc-text">5.扩展</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E6%9C%80%E5%90%8E"><span class="toc-number">7.7.</span> <span class="toc-text">6.最后</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">8.</span> <span class="toc-text">七、负载均衡</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90-6"><span class="toc-number">8.1.</span> <span class="toc-text">1.需求分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">8.2.</span> <span class="toc-text">2.负载均衡</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%B8%B8%E8%A7%81%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95"><span class="toc-number">8.3.</span> <span class="toc-text">3.常见的负载均衡算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7Hash"><span class="toc-number">8.3.1.</span> <span class="toc-text">一致性Hash</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%BC%80%E5%8F%91%E5%AE%9E%E7%8E%B0"><span class="toc-number">8.4.</span> <span class="toc-text">4.开发实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%A7%8D%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%99%A8%E5%AE%9E%E7%8E%B0"><span class="toc-number">8.4.1.</span> <span class="toc-text">多种负载均衡器实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%AF%E6%8C%81%E9%85%8D%E7%BD%AE%E5%92%8C%E6%89%A9%E5%B1%95%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%99%A8"><span class="toc-number">8.4.2.</span> <span class="toc-text">支持配置和扩展负载均衡器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%B5%8B%E8%AF%95"><span class="toc-number">8.5.</span> <span class="toc-text">5.测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E6%89%A9%E5%B1%95"><span class="toc-number">8.6.</span> <span class="toc-text">6.扩展</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6"><span class="toc-number">9.</span> <span class="toc-text">八、重试机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90-7"><span class="toc-number">9.1.</span> <span class="toc-text">1.需求分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88-5"><span class="toc-number">9.2.</span> <span class="toc-text">2.设计方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6"><span class="toc-number">9.2.1.</span> <span class="toc-text">重试机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E8%AF%95%E6%9D%A1%E4%BB%B6"><span class="toc-number">9.2.1.1.</span> <span class="toc-text">重试条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E8%AF%95%E6%97%B6%E9%97%B4"><span class="toc-number">9.2.1.2.</span> <span class="toc-text">重试时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%9C%E6%AD%A2%E9%87%8D%E8%AF%95"><span class="toc-number">9.2.1.3.</span> <span class="toc-text">停止重试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E8%AF%95%E5%B7%A5%E4%BD%9C"><span class="toc-number">9.2.1.4.</span> <span class="toc-text">重试工作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%AF%95%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1"><span class="toc-number">9.2.2.</span> <span class="toc-text">重试方案设计</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%BC%80%E5%8F%91%E5%AE%9E%E7%8E%B0-4"><span class="toc-number">9.3.</span> <span class="toc-text">3.开发实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%A7%8D%E9%87%8D%E8%AF%95%E7%AD%96%E7%95%A5%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">9.3.1.</span> <span class="toc-text">多种重试策略的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%AF%E6%8C%81%E9%85%8D%E7%BD%AE%E5%92%8C%E6%89%A9%E5%B1%95%E9%87%8D%E8%AF%95%E7%AD%96%E7%95%A5"><span class="toc-number">9.3.2.</span> <span class="toc-text">支持配置和扩展重试策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E9%87%8D%E8%AF%95%E5%8A%9F%E8%83%BD"><span class="toc-number">9.3.3.</span> <span class="toc-text">应用重试功能</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%B5%8B%E8%AF%95"><span class="toc-number">9.4.</span> <span class="toc-text">4.测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%89%A9%E5%B1%95-1"><span class="toc-number">9.5.</span> <span class="toc-text">5.扩展</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E5%AE%B9%E9%94%99%E6%9C%BA%E5%88%B6"><span class="toc-number">10.</span> <span class="toc-text">九、容错机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90-8"><span class="toc-number">10.1.</span> <span class="toc-text">1.需求分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88-6"><span class="toc-number">10.2.</span> <span class="toc-text">2.设计方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E9%94%99%E6%9C%BA%E5%88%B6"><span class="toc-number">10.2.1.</span> <span class="toc-text">容错机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E9%94%99%E7%AD%96%E7%95%A5"><span class="toc-number">10.2.1.1.</span> <span class="toc-text">容错策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E9%94%99%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">10.2.1.2.</span> <span class="toc-text">容错实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E9%94%99%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1"><span class="toc-number">10.2.2.</span> <span class="toc-text">容错方案设计</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%BC%80%E5%8F%91%E5%AE%9E%E7%8E%B0-5"><span class="toc-number">10.3.</span> <span class="toc-text">3.开发实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%A7%8D%E5%AE%B9%E9%94%99%E7%AD%96%E7%95%A5%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">10.3.1.</span> <span class="toc-text">多种容错策略的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%AF%E6%8C%81%E9%85%8D%E7%BD%AE%E5%92%8C%E6%89%A9%E5%B1%95%E5%AE%B9%E9%94%99%E7%AD%96%E7%95%A5"><span class="toc-number">10.3.2.</span> <span class="toc-text">支持配置和扩展容错策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%AE%B9%E9%94%99%E5%8A%9F%E8%83%BD"><span class="toc-number">10.3.3.</span> <span class="toc-text">应用容错功能</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%B5%8B%E8%AF%95-1"><span class="toc-number">10.4.</span> <span class="toc-text">4.测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%89%A9%E5%B1%95-2"><span class="toc-number">10.5.</span> <span class="toc-text">5.扩展</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E3%80%81%E5%90%AF%E5%8A%A8%E6%9C%BA%E5%88%B6%E5%92%8C%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8"><span class="toc-number">11.</span> <span class="toc-text">十、启动机制和注解驱动</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90-9"><span class="toc-number">11.1.</span> <span class="toc-text">1.需求分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88-7"><span class="toc-number">11.2.</span> <span class="toc-text">2.设计方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E6%9C%BA%E5%88%B6%E8%AE%BE%E8%AE%A1"><span class="toc-number">11.2.1.</span> <span class="toc-text">启动机制设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1"><span class="toc-number">11.2.2.</span> <span class="toc-text">注解驱动设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-number">11.2.3.</span> <span class="toc-text">实现注解驱动的两种方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%BC%80%E5%8F%91%E5%AE%9E%E7%8E%B0-6"><span class="toc-number">11.3.</span> <span class="toc-text">3.开发实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E6%9C%BA%E5%88%B6"><span class="toc-number">11.3.1.</span> <span class="toc-text">启动机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E8%80%85%E5%90%AF%E5%8A%A8%E7%B1%BB"><span class="toc-number">11.3.1.1.</span> <span class="toc-text">服务提供者启动类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9%E8%80%85%E5%90%AF%E5%8A%A8%E7%B1%BB"><span class="toc-number">11.3.1.2.</span> <span class="toc-text">服务消费者启动类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-Boot-Starter%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8"><span class="toc-number">11.3.2.</span> <span class="toc-text">Spring Boot Starter注解驱动</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89Spring-Boot-Starter%E9%A1%B9%E7%9B%AE%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">11.3.2.1.</span> <span class="toc-text">（1）Spring Boot Starter项目初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3"><span class="toc-number">11.3.2.2.</span> <span class="toc-text">（2）定义注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8"><span class="toc-number">11.3.2.3.</span> <span class="toc-text">（3）注解驱动</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%B5%8B%E8%AF%95-2"><span class="toc-number">11.4.</span> <span class="toc-text">4.测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%89%A9%E5%B1%95-3"><span class="toc-number">11.5.</span> <span class="toc-text">5.扩展</span></a></li></ol></li></ol></div></div><footer><nobr>Published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr> by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas></body></html>